
module("MAGIC-Forest drivers", version(0, 0, 3),
	comp      : compartment,
	hydro     : compartment,
	ca        : quantity,
	mg        : quantity,
	na        : quantity,
	k         : quantity,
	nh4       : quantity,
	so4       : quantity,
	cl        : quantity,
	no3       : quantity,
	f         : quantity,
	po4       : quantity,
	ts        : property,
	ext_in    : property,
	bal       : property,
	conc_oa   : property,
	temp      : property,
	concn     : property,
	conc_all  : property,
	mod_runoff: property,
	rel_runoff: property,
	air_t     : property,
	precip    : property,
	upt       : property,
	rel_area  : par_real,
	use_mod_q : par_enum,
	con       : connection
) {
	
	par_group("Overall climate parameters") {
		pr_par: par_real("Precipitation", [m, year-1], 1, 0, 5000, "Used when time series is not available")
		ro_par: par_real("Runoff", [m, year-1], 1, 0, 5000, "Used when time series is not available")
		tm_par: par_real("Air temperature", [deg_c], 4, 0, 50, "Used when time series is not available")
	}
	
	par_group("Climate parameters", comp) {
		is_top: par_bool("This is a surface compartment", true, "If true it receives deposition")
		ro_scale : par_real("Runoff scale", [], 1, 0, 1, "Scale runoff to per m-2 of this compartment")
		min_t : par_real("Minimal compartment temperature", [deg_c], 0.4, -10, 10)
		oa    : par_real("Organic acid concentration", [m mol, m-3], 0, 0, 200)
		adjoa : par_bool("Adjust OA concentration", false, "Adjust based on SO4 concentration")
		redoa : par_real("Reduction in OA by SO4", [m mol, m eq-1], 0)
	}
	
	par_group("Weathering", comp) {
		w_ca  : par_real("Ca weathering", [m eq, m-2, year-1], 0)
		w_mg  : par_real("Mg weathering", [m eq, m-2, year-1], 0)
		w_na  : par_real("Na weathering", [m eq, m-2, year-1], 0)
		w_k   : par_real("K weathering", [m eq, m-2, year-1], 0)
		w_nh4 : par_real("NH4 weathering", [m eq, m-2, year-1], 0)
		w_so4 : par_real("SO4 weathering", [m eq, m-2, year-1], 0)
		w_cl  : par_real("Cl weathering", [m eq, m-2, year-1], 0)
		w_no3 : par_real("NO3 weathering", [m eq, m-2, year-1], 0)
		w_f   : par_real("F weathering", [m eq, m-2, year-1], 0)
		w_po4 : par_real("PO4 weathering", [m eq, m-2, year-1], 0)
	}
	
	par_group("Sink parameters", comp) {
		u_ca  : par_real("Ca sink", [m eq, m-2, year-1], 0, -100, 100, "Negative rate sets value as % of inputs")
		u_mg  : par_real("Mg sink", [m eq, m-2, year-1], 0, -100, 100, "Negative rate sets value as % of inputs")
		u_na  : par_real("Na sink", [m eq, m-2, year-1], 0, -100, 100, "Negative rate sets value as % of inputs")
		u_k   : par_real("K sink", [m eq, m-2, year-1], 0, -100, 100, "Negative rate sets value as % of inputs")
		u_nh4 : par_real("NH4 sink", [m eq, m-2, year-1], 0, -100, 100, "Negative rate sets value as % of inputs")
		u_so4 : par_real("SO4 sink", [m eq, m-2, year-1], 0, -100, 100, "Negative rate sets value as % of inputs")
		u_cl  : par_real("Cl sink", [m eq, m-2, year-1], 0, -100, 100, "Negative rate sets value as % of inputs")
		u_no3 : par_real("NO3 sink", [m eq, m-2, year-1], 0, -100, 100, "Negative rate sets value as % of inputs")
		u_f   : par_real("F sink", [m eq, m-2, year-1], 0, -100, 100, "Negative rate sets value as % of inputs")
		u_po4 : par_real("PO4 sink", [m eq, m-2, year-1], 0, -100, 100, "Negative rate sets value as % of inputs")
	}
	
	par_group("Deposition parameters") {
		d_ca  : par_real("Ca conc in precipitation", [m eq, m-3], 0, 0, 200, "Used when time series is not available")
		d_mg  : par_real("Mg conc in precipitation", [m eq, m-3], 0, 0, 200, "Used when time series is not available")
		d_na  : par_real("Na conc in precipitation", [m eq, m-3], 0, 0, 200, "Used when time series is not available")
		d_k   : par_real("K conc in precipitation", [m eq, m-3], 0, 0, 200, "Used when time series is not available")
		d_nh4 : par_real("NH4 conc in precipitation", [m eq, m-3], 0, 0, 200, "Used when time series is not available")
		d_so4 : par_real("SO4 conc in precipitation", [m eq, m-3], 0, 0, 200, "Used when time series is not available")
		d_cl  : par_real("Cl conc in precipitation", [m eq, m-3], 0, 0, 200, "Used when time series is not available")
		d_no3 : par_real("NO3 conc in precipitation", [m eq, m-3], 0, 0, 200, "Used when time series is not available")
		d_f   : par_real("F conc in precipitation", [m eq, m-3], 0, 0, 200, "Used when time series is not available")
		d_po4 : par_real("PO4 conc in precipitation", [m eq, m-3], 0, 0, 200, "Used when time series is not available")
		sea_salt : par_bool("Sea salt deposition", true, "If on, wet deposition scale only scales non-marine deposition")
	}
	
	var(comp.conc_oa, [m mol, m-3], "Organic acid concentration") {
		max(0, oa - adjoa*(last(so4.conc_all)*redoa))
	} @initial {
		#TODO: Fix bug. This should be required to exist since it is used in the initial of the external_computation
		#TODO: Fix bug. Having a last() on so4 conc here crashes instead of getting detected or removed!
		max(0, oa - adjoa*(so4.conc_all*redoa) )
	}
	
	qout : property("Runoff")
	
	# NOTE: These three can be overridden with input series
	var(comp.air_t, [deg_c], "Air temperature") { tm_par }
	var(comp.qout, [m m, month-1]) { ro_par*ts ->> }
	var(comp.precip, [m m, month-1]) { pr_par*ts ->> }
	
	var(comp.temp, [deg_c], "Temperature") {
		max(air_t, min_t)
	}
	
	var(comp.ts, [year, month-1]) {
		time.step_length_in_seconds*1[month-1] / (time.days_this_year * 86400[s, day-1])
	} @no_store
	
	option(use_mod_q.no) {
		# TODO: It is not the best solution to make the user input the ro_scale
		# (even more complicated if you have more chained parameters)
		# (scale is sum of rel_area of compartments before it including itself, divided by rel_area of itself)
		# (before only counts those sideways, not those in a layer above)
		var(comp.rel_runoff, [m, month-1]) {
			qout*ro_scale->>
			#(qout / rel_area)->>   if is_finite(qout) & qout > 1e-6[m m, month-1],
			#ro_par*ts              otherwise
		} @no_store
	} @otherwise {
		var(comp.rel_runoff, [m, month-1]) {
			q := {
				qout if is_finite(qout) & !use_mod_q.always,
				hydro.mod_runoff otherwise
			},
			q*ro_scale->>
		} @no_store
	}
	
	tot_dep : property("Total deposition")
	
	var(comp.ca.tot_dep, [m eq, m-2, month-1], "Ca total deposition") @clear_nan
	var(comp.mg.tot_dep, [m eq, m-2, month-1], "Mg total deposition") @clear_nan
	var(comp.na.tot_dep, [m eq, m-2, month-1], "Na total deposition") @clear_nan
	var(comp.k.tot_dep, [m eq, m-2, month-1], "K total deposition") @clear_nan
	var(comp.nh4.tot_dep, [m eq, m-2, month-1], "NH4 total deposition") @clear_nan
	var(comp.so4.tot_dep, [m eq, m-2, month-1], "SO4 total deposition") @clear_nan
	var(comp.cl.tot_dep, [m eq, m-2, month-1], "Cl total deposition") @clear_nan
	var(comp.no3.tot_dep, [m eq, m-2, month-1], "NO3 total deposition") @clear_nan
	var(comp.f.tot_dep, [m eq, m-2, month-1], "F total deposition") @clear_nan
	var(comp.po4.tot_dep, [m eq, m-2, month-1], "PO4 total deposition") @clear_nan
	
	wetds : property("Wet deposition scale")
	
	var(comp.ca.wetds, [], "Ca wet deposition scale") @clear_nan
	var(comp.mg.wetds, [], "Mg wet deposition scale") @clear_nan
	var(comp.na.wetds, [], "Na wet deposition scale") @clear_nan
	var(comp.k.wetds, [], "K wet deposition scale") @clear_nan
	var(comp.nh4.wetds, [], "NH4 wet deposition scale") @clear_nan
	var(comp.so4.wetds, [], "SO4 wet deposition scale") @clear_nan
	var(comp.cl.wetds, [], "Cl wet deposition scale") @clear_nan
	var(comp.no3.wetds, [], "NO3 wet deposition scale") @clear_nan
	var(comp.f.wetds, [], "F wet deposition scale") @clear_nan
	var(comp.po4.wetds, [], "PO4 wet deposition scale") @clear_nan
	
	dep : property("Deposition")
	
	#TODO: also apply a dry deposition scale
	
	compute_deposition : function(wet, wet_scale, tot_dep, is_top) {
		{
			tot_dep       if is_finite(tot_dep),
			wet_scale*wet if is_finite(wet_scale),
			wet           otherwise
		} * is_top
	}
	
	compute_deposition_sea_salt : function(wet, wet_scale, tot_dep, is_top, cl_wet, ss_scale) {
		{
			tot_dep if is_finite(tot_dep),
			{
				ss := min(wet, cl_wet*ss_scale),  # Sea salt deposition
				ex := wet-ss,                     # Non-marine deposition
				ex*wet_scale + ss   # Only applying wet_deposition scale to non-marine deposition
			}       if is_finite(wet_scale),
			wet     otherwise
		} * is_top
	}
	
	#TODO: These should only take into account cl wet deposition too in case we introduce dry dep later.
	var(comp.ca.dep, [m eq, m-2, month-1], "Ca deposition") {
		wet := precip*d_ca->>,
		clwet := precip*d_cl->>,
		compute_deposition_sea_salt(wet, wetds, tot_dep, is_top, clwet, 0.0376) if sea_salt,
		compute_deposition(wet, wetds, tot_dep, is_top) otherwise
	}
	
	var(comp.mg.dep, [m eq, m-2, month-1], "Mg deposition") {
		wet := precip*d_mg->>,
		clwet := precip*d_cl->>,
		compute_deposition_sea_salt(wet, wetds, tot_dep, is_top, clwet, 0.1920) if sea_salt,
		compute_deposition(wet, wetds, tot_dep, is_top) otherwise
	}
	
	var(comp.na.dep, [m eq, m-2, month-1], "Na deposition") {
		wet := precip*d_na->>,
		clwet := precip*d_cl->>,
		compute_deposition_sea_salt(wet, wetds, tot_dep, is_top, clwet, 0.8580) if sea_salt,
		compute_deposition(wet, wetds, tot_dep, is_top) otherwise
	}
	
	var(comp.k.dep, [m eq, m-2, month-1], "K deposition") {
		wet := precip*d_k->>,
		clwet := precip*d_cl->>,
		compute_deposition_sea_salt(wet, wetds, tot_dep, is_top, clwet, 0.0188) if sea_salt,
		compute_deposition(wet, wetds, tot_dep, is_top) otherwise
	}
	
	var(comp.nh4.dep, [m eq, m-2, month-1], "NH4 deposition") {
		compute_deposition(precip*d_nh4->>, wetds, tot_dep, is_top)
	}
	
	var(comp.so4.dep, [m eq, m-2, month-1], "SO4 deposition") {
		wet := precip*d_so4->>,
		clwet := precip*d_cl->>, # not comp.cl.dep, should not take into account cl dep sequence it looks like (?)
		compute_deposition_sea_salt(wet, wetds, tot_dep, is_top, clwet, 0.1040) if sea_salt,
		compute_deposition(wet, wetds, tot_dep, is_top) otherwise
	}
	
	var(comp.cl.dep, [m eq, m-2, month-1], "Cl deposition") {
		compute_deposition(precip*d_cl->>, wetds, tot_dep, is_top)
	}
	
	var(comp.no3.dep, [m eq, m-2, month-1], "NO3 deposition") {
		compute_deposition(precip*d_no3->>, wetds, tot_dep, is_top)
	}
	
	var(comp.f.dep, [m eq, m-2, month-1], "F deposition") {
		compute_deposition(precip*d_f->>, wetds, tot_dep, is_top)
	}
	
	var(comp.po4.dep, [m eq, m-2, month-1], "PO4 deposition") {
		compute_deposition(precip*d_po4->>, wetds, tot_dep, is_top)
	}
	
	var(comp.ca.ext_in, [m eq, m-2, month-1]) { w_ca*ts + dep } @no_store
	var(comp.mg.ext_in, [m eq, m-2, month-1]) { w_mg*ts + dep } @no_store
	var(comp.na.ext_in, [m eq, m-2, month-1]) { w_na*ts + dep } @no_store
	var(comp.k.ext_in, [m eq, m-2, month-1]) { w_k*ts + dep } @no_store
	var(comp.nh4.ext_in, [m eq, m-2, month-1]) { w_nh4*ts + dep } @no_store
	var(comp.so4.ext_in, [m eq, m-2, month-1]) { w_so4*ts + dep } @no_store
	var(comp.cl.ext_in, [m eq, m-2, month-1]) { w_cl*ts + dep } @no_store
	var(comp.no3.ext_in, [m eq, m-2, month-1]) { w_no3*ts + dep } @no_store
	var(comp.f.ext_in, [m eq, m-2, month-1]) { w_f*ts + dep } @no_store
	var(comp.po4.ext_in, [m eq, m-2, month-1]) { w_po4*ts + dep } @no_store
	
	#NOTE: These are the mass balance of all inputs - all outputs except for the discharge output.
	# Only used to compute initial concentrations
	var(comp.ca.bal, [m eq, m-2, month-1]) { in_flux(ca) - out_flux(ca) + in_flux(con, ca) } @no_store
	var(comp.mg.bal, [m eq, m-2, month-1]) { in_flux(mg) - out_flux(mg) + in_flux(con, mg) } @no_store
	var(comp.na.bal, [m eq, m-2, month-1]) { in_flux(na) - out_flux(na) + in_flux(con, na) } @no_store
	var(comp.k.bal, [m eq, m-2, month-1]) { in_flux(k) - out_flux(k) + in_flux(con, k) } @no_store
	var(comp.nh4.bal, [m eq, m-2, month-1]) { in_flux(nh4) - out_flux(nh4) + in_flux(con, nh4) } @no_store
	var(comp.so4.bal, [m eq, m-2, month-1]) { in_flux(so4) - out_flux(so4) + in_flux(con, so4) } @no_store
	var(comp.cl.bal, [m eq, m-2, month-1]) { in_flux(cl) - out_flux(cl) + in_flux(con, cl) } @no_store
	var(comp.no3.bal, [m eq, m-2, month-1]) { in_flux(no3) - out_flux(no3) + in_flux(con, no3) } @no_store
	var(comp.f.bal, [m eq, m-2, month-1]) { in_flux(f) - out_flux(f) + in_flux(con, f) } @no_store
	var(comp.po4.bal, [m eq, m-2, month-1]) { in_flux(po4) - out_flux(po4) + in_flux(con, po4) } @no_store
	
	flux(out, comp.ca,  [m eq, m-2, month-1], "Ca external inputs")  { ext_in }
	flux(out, comp.mg,  [m eq, m-2, month-1], "Mg external inputs")  { ext_in }
	flux(out, comp.na,  [m eq, m-2, month-1], "Na external inputs")  { ext_in }
	flux(out, comp.k,   [m eq, m-2, month-1], "K external inputs")   { ext_in }
	flux(out, comp.nh4, [m eq, m-2, month-1], "NH4 external inputs") { ext_in }
	flux(out, comp.so4, [m eq, m-2, month-1], "SO4 external inputs") { ext_in }
	flux(out, comp.cl,  [m eq, m-2, month-1], "Cl external inputs")  { ext_in }
	flux(out, comp.no3, [m eq, m-2, month-1], "NO3 external inputs") { ext_in }
	flux(out, comp.f,   [m eq, m-2, month-1], "F external inputs")   { ext_in }
	flux(out, comp.po4, [m eq, m-2, month-1], "PO4 external inputs") { ext_in }
	
	#TODO: Should this take into account flow inputs as well, not just external inputs?
	compute_uptake : function(u, upt, ext_in, ts) {
		upt                  if is_finite(upt),
		u*ts                 if u > 0,
		-ext_in*(u=>[])*0.01 otherwise
	}
	
	upt_in : property("Uptake inputs")
	
	var(comp.ca.upt_in, [m eq, m-2, month-1], "Ca dynamic sink") @clear_nan
	var(comp.mg.upt_in, [m eq, m-2, month-1], "Mg dynamic sink") @clear_nan
	var(comp.na.upt_in, [m eq, m-2, month-1], "Na dynamic sink") @clear_nan
	var(comp.k.upt_in, [m eq, m-2, month-1], "K dynamic sink") @clear_nan
	var(comp.nh4.upt_in, [m eq, m-2, month-1], "NH4 dynamic sink") @clear_nan
	var(comp.so4.upt_in, [m eq, m-2, month-1], "SO4 dynamic sink") @clear_nan
	var(comp.cl.upt_in, [m eq, m-2, month-1], "Cl dynamic sink") @clear_nan
	var(comp.no3.upt_in, [m eq, m-2, month-1], "NO3 dynamic sink") @clear_nan
	var(comp.f.upt_in, [m eq, m-2, month-1], "F dynamic sink") @clear_nan
	var(comp.po4.upt_in, [m eq, m-2, month-1], "PO4 dynamic sink") @clear_nan
	
	var(comp.ca.upt, [m eq, m-2, month-1], "Ca sink")  { compute_uptake(u_ca, upt_in, ext_in, ts) } @no_store
	var(comp.mg.upt, [m eq, m-2, month-1], "Mg dynamic sink") { compute_uptake(u_mg, upt_in, ext_in, ts) } @no_store
	var(comp.na.upt, [m eq, m-2, month-1], "Na dynamic sink") { compute_uptake(u_na, upt_in, ext_in, ts) } @no_store
	var(comp.k.upt, [m eq, m-2, month-1], "K dynamic sink") { compute_uptake(u_k, upt_in, ext_in, ts) } @no_store
	var(comp.nh4.upt, [m eq, m-2, month-1], "NH4 dynamic sink") { compute_uptake(u_nh4, upt_in, ext_in, ts) } @no_store
	var(comp.so4.upt, [m eq, m-2, month-1], "SO4 dynamic sink") { compute_uptake(u_so4, upt_in, ext_in, ts) } @no_store
	var(comp.cl.upt, [m eq, m-2, month-1], "Cl dynamic sink") { compute_uptake(u_cl, upt_in, ext_in, ts) } @no_store
	var(comp.no3.upt, [m eq, m-2, month-1], "NO3 dynamic sink")  { compute_uptake(u_no3, upt_in, ext_in, ts) } @no_store
	var(comp.f.upt, [m eq, m-2, month-1], "F dynamic sink") { compute_uptake(u_f, upt_in, ext_in, ts) } @no_store
	var(comp.po4.upt, [m eq, m-2, month-1], "PO4 dynamic sink") { compute_uptake(u_po4, upt_in, ext_in, ts) } @no_store
	
	
	flux(comp.ca, out, [m eq, m-2, month-1], "Ca sinks") { upt }
	flux(comp.mg, out, [m eq, m-2, month-1], "Mg sinks") { upt }
	flux(comp.na, out, [m eq, m-2, month-1], "Na sinks") { upt }
	flux(comp.k, out, [m eq, m-2, month-1], "K sinks") { upt }
	flux(comp.nh4, out, [m eq, m-2, month-1], "NH4 sinks") { upt }
	flux(comp.so4, out, [m eq, m-2, month-1], "SO4 sinks") { upt }
	flux(comp.cl, out, [m eq, m-2, month-1], "Cl sinks") { upt }
	flux(comp.no3, out, [m eq, m-2, month-1], "NO3 sinks") { upt }
	flux(comp.f, out, [m eq, m-2, month-1], "F sinks") { upt }
	flux(comp.po4, out, [m eq, m-2, month-1], "PO4 sinks") { upt }
	
	#TODO: Would be nice to use automatic transport, but it would require more framework functionality
	# This is because the transported concentration is not the total mass divided by water for all these
	# Maybe allow specifying a @transportable_concentration note.
	
	flux(comp.ca,  con, [m eq, m-2, month-1], "Ca discharge")  { concn*rel_runoff }
	flux(comp.mg,  con, [m eq, m-2, month-1], "Mg discharge")  { concn*rel_runoff }
	flux(comp.na,  con, [m eq, m-2, month-1], "Na discharge")  { concn*rel_runoff }
	flux(comp.k,   con, [m eq, m-2, month-1], "K discharge")   { concn*rel_runoff }
	flux(comp.nh4, con, [m eq, m-2, month-1], "NH4 discharge") { concn*rel_runoff }
	flux(comp.so4, con, [m eq, m-2, month-1], "SO4 discharge") { conc_all*rel_runoff }
	flux(comp.cl,  con, [m eq, m-2, month-1], "Cl discharge")  { concn*rel_runoff }
	flux(comp.no3, con, [m eq, m-2, month-1], "NO3 discharge") { concn*rel_runoff }
	flux(comp.f,   con, [m eq, m-2, month-1], "F discharge")   { conc_all*rel_runoff }
	flux(comp.po4, con, [m eq, m-2, month-1], "PO4 discharge") { concn*rel_runoff }
	
	

}

module("SimplyP", version(0, 6, 0),
	soil    : compartment,
	gw      : compartment,
	river   : compartment,
	water   : quantity,
	phos    : quantity,
	plab    : quantity,
	sed     : quantity,
	e_fact  : property,
	tp      : property,
	tdp     : property,
	a_catch : par_real
) {
"""
SimplyP is a parsimonious phosphorus model. It was originally implemented in Python and published as

[Jackson-Blake LA, Sample JE, Wade AJ, Helliwell RC, Skeffington RA. 2017. Are our dynamic water quality models too complex? A comparison of a new parsimonious phosphorus model, SimplyP, and INCA-P. Water Resources Research, 53, 5382â€“5399. doi:10.1002/2016WR020132](https://doi.org/10.1002/2016WR020132)

For news, updates and references, see [the model's github home page](https://github.com/NIVANorge/Mobius/tree/master/Applications/SimplyP)

New to version 0.6:
* The model has been ported to Mobius2. Everything is solved as one large coupled ODE system.

New to version 0.4:
* Landscape units are dynamic and user-specified instead of hardcoded.
* Sediment and hydrology equations are factored out into separate modules (SimplyQ, SimplySed)

New to version 0.3:
* More realistic hydrology.

[Detailed development log](https://github.com/NIVANorge/Mobius/blob/master/Applications/SimplyP/SimplyP_development_log.txt)

For reference, here is [the original Python implementation of SimplyP](https://github.com/LeahJB/SimplyP), which is no longer being developed.
"""	
	
	load("stdlib/basic_math.txt", library("Basic"))
	
	par_group("P general") {
		dyn_epc0  : par_bool("Dynamic EPC0, TDP and soil labile P", true)
		m_soil_m2 : par_real("Soil mass per m2", [k g, m-2], 95, 0, 200)
		kf        : par_real("Phosphorous sorption coefficient", [l, m g-1], 1.13e-4, 0, 0.1)
		pp_enrich : par_real("Particulate P enrichment factor", [], 1.6, 1, 5)
	}
	
	par_group("Soil P", soil) {
		init_epc0            : par_real("Initial soil TDP concentration and EPC0", [m g, l-1], 0.1, 0, 10)
		init_soil_p_conc     : par_real("Initial total soil P content", [m g, k g-1], 1458, 0, 10000)
		inactive_soil_p_conc : par_real("Inactive soil P content", [m g, k g-1], 873, 0, 10000)
		p_input              : par_real("Net annual P input to soil", [k g, ha-1, year-1], 0, -100, 100)
	}
	
	par_group("Groundwater P", gw) {
		gw_tdp : par_real("Groundwater TDP concentration", [m g, l-1], 0, 0, 10)
	}
	
	par_group("River P", river) {
		eff_tdp   : par_real("Effluent TDP inputs", [k g, day-1], 0, 0, 10)
	}
	
	epc0 : property("EPC0")
	
	var(soil.epc0, [m g, l-1]) {
		m_soil := m_soil_m2->[k g, k m-2],
		
		safe_divide(last(plab), kf * m_soil)  if dyn_epc0,
		init_epc0                             otherwise
	} @initial { init_epc0 }
	
	# NOTE: The soil TDP mass is described by the ODE equation
	
		# d(TDPs)/dt  = input - kf*m_soil*(TDPs/water - epc0) - flow*TDPs/water
	
	# This equation is generally stiff. However, if we assume that flow (soil water flow) and water are approximately constant over the time step, we have an equation on the form
	
		# d(TDPs)/dt  = (input + kf*m_soil*epc0)  -  ((kf*m_soil + flow) / water)*TDPs
		            # = a - b*TDPs
	# This has the exact solution TDPs(t) = a/b + (TDPs(0) - a/b) * exp(-b*t)   , where we can insert t=1 to integrate over the time step.
	# Solving it this way saves time by a factor of about 50-100, and has miniscule error compared to solving it with time-variable water and flow.
	
	# Now, the soil labile P mass is described by
		# d(Plab)/dt  = kf*m_soil*((TDPs/water)-epc0)
	# So
		# Plab(1) = Plab(0) + Integral(kf*m_soil*((TDPs(t)/water) - epc0), t=0->1)
	
	# Again, assuming constant water, the integral will be
		# I = (kf*m_soil)*( (1/water)*Integral(TDPs(t), t=0->1) - EPC0)
		  # = (kf*m_soil)*( (1/water)(a/b + (TDPs(0)-a/b)*(1/b)*(1 - exp(-b)) ) - EPC0)
		  # = (kf*m_soil)*( (1/(water*b))(a + (TDPs(0) - a/b)(1 - exp(-b)) ) - EPC0)
	
	var(soil.water.phos, [k g, k m-2], [m g, l-1], "Soil DIP mass") @override {
		{
			days   := time.step_length_in_seconds->[day],
			pin    := p_input * days / time.days_this_year ->[k g, k m-2],
			m_soil := m_soil_m2->[k g, k m-2],
			a      := (pin + kf*m_soil*epc0),
			bV     := (kf*m_soil + last(out_flux(soil.water))*days),
			b      := bV / last(water),
			a/b + (last(water.phos) - a/b)*exp(-b)
		}                     if dyn_epc0,
		init_epc0 * water ->> otherwise
	} @initial_conc {
		init_epc0
	}
	
	var(soil.plab, [k g, k m-2], "Soil labile P mass") @override {
		{
			days   := time.step_length_in_seconds->[day],
			pin    := p_input * days / time.days_this_year ->[k g, k m-2],
			m_soil := m_soil_m2->[k g, k m-2],
			a      := (pin + kf*m_soil*epc0),
			bV     := (kf*m_soil + last(out_flux(soil.water))*days),
			b      := bV / last(water),
			sorp   := (kf*m_soil)*( (1/bV)*(a + (last(water.phos) - a/b)*(1 - exp(-b))) - epc0),
			last(plab) + sorp
		}           if dyn_epc0,
		last(plab)  otherwise
	} @initial {
		(init_soil_p_conc - inactive_soil_p_conc) * m_soil_m2
	}
	
	
	plabconc : property("Labile P concentration")

	var(soil.plab.plabconc, [m g, k g-1]) {  plab / m_soil_m2  }
	
	var(gw.water.phos, [k g, k m-2], [m g, l-1], "Groundwater DIP") @initial_conc { gw_tdp } @override_conc { gw_tdp }
	
	var(river.water.phos, [k g], [m g, l-1], "River DIP") @initial_conc { gw_tdp }
	
	flux(out, river.water.phos, [k g, day-1], "River effluent DIP") { eff_tdp }
	
	var(river.water.sed.phos, [k g], "River PP")
	@show_conc(river.water, [m g, l-1])      # The default concentration displayed is the conc of phos in sed. We want conc of phos in water.
	
	pp_fact : property("PP mobilization factor")

	var(soil.plab.pp_fact, [k g, k m-2, day-1]) {
		(plabconc + inactive_soil_p_conc) * e_fact * pp_enrich ->>
	}
	
	flux(out, river.water.sed.phos, [k g, day-1], "PP mobilization") {
		a_catch * river.e_fact * aggregate(soil.plab.pp_fact)
	}
	
	var(river.water.tp, [m g, l-1], "River TP") {
		conc(phos) + conc(sed)*conc(sed.phos)   # NOTE: conc(sed.phos) still refers to the default concentration of phos in sed, not in water, hence we must multiply.
	}
	
	var(river.water.tdp, [m g, l-1], "River TDP") { # NOTE: Other modules for organic P can add to this.
		conc(phos)
	}
}



module("SimplyQ land", 0, 5, 0) {
"""
This is an adaption of a hydrology module originally implemented in Python as a part of the model SimplyP, which was published as

[Jackson-Blake LA, Sample JE, Wade AJ, Helliwell RC, Skeffington RA. 2017. Are our dynamic water quality models too complex? A comparison of a new parsimonious phosphorus model, SimplyP, and INCA-P. Water Resources Research, 53, 5382â€“5399. doi:10.1002/2016WR020132](https://doi.org/10.1002/2016WR020132)
"""
	load("stdlib/basic_math.txt", library("Response"))

	soil     : compartment("Soil")
	gw       : compartment("Groundwater")
	river    : compartment("River")
	
	water : quantity("Water")
	
	soil.par_group("Hydrology general") {
		bfi    : par_real("Baseflow index", [],                        0.6,  0,    1)
		qqinfl : par_real("Quick flow inflection point", [m m, day-1], 160, 20,  500)
	}
	
	soil.par_group("Hydrology land") {
		fc     : par_real("Field capacity", [m m],                     120,  0, 1000)
		tc_s   : par_real("Soil water time constant", [day],           2,  1,   40)
	}
		
	gw.  par_group("Groundwater") {
		tc_g    : par_real("Groundwater time constant", [day],       30,  1,  400)
	}
	
	a_catch : par_real("Catchment area", [k m 2]) # NOTE: This is a reference to a parameter that must be declared in the model file.
	
	soil.has(water, [m m], "Soil water volume") .initial { fc }
	gw  .has(water, [m m], "Groundwater volume") .initial {
		tc_g * river.water.flow / a_catch -> [m m]
	}

	pet  : property("Potential evapotranspiration")
	
	quick_flow :
	flux(soil.water, out, [m m, day-1], "Quick flow") {
		drylim := 0.9		# Could be a parameter. Stops quick flow below drylim*fc
		flow   := in_flux(water)
		#flow * s_response(water, drylim*fc, fc, 0, 1) * (2 / (1 + exp(-flow/qqinfl)) - 1)
		flow * s_response(water, drylim*fc, fc, 0, 1) * atan(flow/qqinfl)*2/pi
	}
	
	evap :
	flux(soil.water, nowhere, [m m, day-1], "Evapotranspiration") {   
		s_response(water, 0.5*fc, fc, 0, pet)
	} 
	
	soil.water.has(flow : property("Flow"), [m m, day -1], "Soil water flow") {
		rate := (water - fc)/tc_s
		s_response(water, fc, 1.01*fc, 0, rate) # smoothly turn the rate on between water volumes of fc and 1.01*fc
	}
	
	soil_runoff :
	flux(soil.water, out, [m m, day-1], "Soil runoff")            {   flow * (1 - bfi)   }
	
	flux(soil.water, gw.water, [m m, day-1], "Recharge")          {   flow * bfi   }
	
	gw_runoff :
	flux(gw.water, out, [m m, day-1], "Groundwater runoff")       {   water / tc_g   }
}


module("SimplyQ river", 0, 0, 1) {
"""
The river part of the SimplyQ module.
"""

	river : compartment("River")
	
	water : quantity("Water")
	
	river.par_group("Reach parameters") {
		slope          : par_real("Reach slope", [],                             0.014, 0.00001,        3)
		len            : par_real("Reach length", [m],                           10000,       0, 10000000)
		c_mann         : par_real("Manning's roughness coefficient", [s, m-1/3],  0.04,   0.012,      0.1, 
			"Default of 0.04 is for clean winding natural channels. See e.g. Chow 1959 for a table of values for other channel types")
		init_flow      : par_real("Initial reach flow", [m 3, s-1],                  1,       0,     100)
	}
	
	flow : property("Flow")
	
	river.has(water, [m 3], "Reach water volume") .initial {
		q := init_flow => []   # Force it as dimensionless since it doesn't make sense to take fractional powers of it otherwise
		depth := 0.349[m] * q^0.34
		width := 2.71[m] * q^0.557
		width * depth * len
	}
	
	# TODO: ideally we should here be able to cut the property "Flow", but unfortunately it is being used by the gw module...

	# NOTE: Empirical formula, so the units don't make sense, hence force conversion.
	river.water.has(flow, [m 3, s-1], "Reach flow")    { 0.28[m 3, s-1] * (water * sqrt(slope) / (len * c_mann) =>[] )^1.5   } .initial { init_flow }
	
	reach_out :
	flux(river.water, out, [m 3, s-1], "Reach flow flux")     {	 flow ->>  }
}

module("SimplyQ river trapezoid", 0, 0, 1) {
"""
Alternative version of the SimplyQ river module assuming trapezoid cross-section of the river.
"""

	river : compartment("River")
	
	water : quantity("Water")
	
	river.par_group("Reach parameters") {
		slope          : par_real("Reach slope", [],                             0.014, 0.00001,        3)
		sb             : par_real("Reach bank slope", [],                            1, 0.00001,       10)
		wb             : par_real("Reach bottom width", [m],                         2,     0.1,    10000)
		len            : par_real("Reach length", [m],                           10000,       0, 10000000)
		c_mann         : par_real("Manning's roughness coefficient", [s, m-1/3],  0.04,   0.012,      0.1, 
			"Default of 0.04 is for clean winding natural channels. See e.g. Chow 1959 for a table of values for other channel types")
		init_flow      : par_real("Initial reach flow", [m 3, s-1],                  1,       0,     100)
	}
	
	flow : property("Flow")
	Rh   : property("Hydraulic radius")
	
	river.has(Rh, [m]) {
		A := water/len
		A / (wb + 2*sqrt( ( (wb*sb)^2 + 4*A*sb ) / (1 + sb^2) ) )
	}
	
	river.has(water, [m 3], "Reach water volume") .initial {
		#This is not exactly correct, and so will not cause the right initial reach flow.. :( Assumes rectangular instead of trapezoid cross-section and uses depth instead of hydraulic radius. But will not be very far off, and it will correct itself quickly.
		(flow*c_mann*cbrt(wb^2)/sqrt(slope) =>[])^(3/5.) =>>
	}

	river.water.has(flow, [m 3, s -1], "Reach flow")    { (water/len)*Rh^(2/3.)*sqrt(slope)/c_mann   } .initial { init_flow }
	
	reach_out :
	flux(river.water, out, [m 3, day-1], "Reach flow flux")     {	 flow ->>  }
}


# NOTE: Not a finished module... Just doodling.

module("Downwelling shortwave", 1, 0, 0) {

	load("../stdlib/atmospheric.txt", "Radiation")
	
	air     : compartment("Atmosphere")
	ground  : compartment_type("Ground surface")            #in model can have soil.is(ground) and lake.is(ground) etc.
	
	down_sw : property("Downwelling shortwave")
	cc      : property("Cloud cover")
	
	# soil.extern_par_group("Land properties")
	# elev : par_real(
	# latitude : par_real
	# Or instead just have latitude be a model parameter.
	
	# formula of elevation and cloud cover.
	ground.has(down_sw, unit(W, m -2) {
		extr := daily_average_extraterrestrial_radiation(latitude, time.day_of_year)
		extr * (1 - air.cc) * (0.75 + 2e-5*elev)                                          #TODO: dependence on cc not correctly computed.
	}
}

module("Net shortwave", 1, 0, 0) {

	air      : compartment("Atmosphere")
	ground   : compartment_type("Ground")
	snow_box : compartment("Snow box")
	
	snow     : quantity("Snow (water equivalents)")    #TODO: should be able to specify what unit we expect it in.
	
	down_sw : property("Downwelling shortwave")
	net_sw  : property("Net shortwave")
	
	ground.par_group("Land albedo") {                     # TODO: How to make this one work in practice ? lu and lake could be distributed differently for instance.
		lalb : par_real("Land albedo", unit(), 0.23, 0, 1)
		salb : par_real("Snow albedo", unit(), 0.8,  0, 1)
	}
	
	ground.has(net_sw, unit(W, m-2)) {
		alb := {
			lalb     if snow_box.snow < 0.5,
			salb     otherwise
		}
		down_sw * (1 - alb)
	}
}

module("Downwelling longwave", 1, 0, 0) {
	air      : compartment("Atmosphere")

}


# TODO: longwave!
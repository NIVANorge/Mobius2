
module("NIVAFjord", 0, 0, 1) {

	load("../../stdlib/basic_math.txt", library("Basic"))
	load("../../stdlib/physiochemistry.txt", library("Water utils"), library("Basic constants"), library("Thermodynamics"))
	load("../../stdlib/seawater.txt", library("Seawater"), library("Air-sea"))
	load("../../stdlib/atmospheric.txt", library("Meteorology"))#, library("Radiation"))

	air   : compartment("Atmosphere")
	oair  : compartment("Ocean air")   # Air right above a given ocean section. Better name?
	layer : compartment("Fjord layer")
	sed   : compartment("Fjord sediment")
	
	water : quantity("Water")
	salt  : quantity("Salt")
	heat  : quantity("Thermal energy")
	
	temp : property("Temperature")
	pressure : property("Pressure")

	air.has(temp,      [deg_c], "Air temperature")
	air.has(wind     : property("Wind speed"),        [m, s-1])
	air.has(g_rad    : property("Global radiation"),  [W, m-2])
	
	
	vert : connection("Fjord vertical", grid1d) { layer* }
	
	layer.par_group("Layer parameters") {
		A      : par_real("Layer area", [m 2], 10000, 0, 1e6)
		init_S : par_real("Initial salinity", [g, k g-1], 35.0, 20.0, 50.0)
		init_T : par_real("Initial temperature", [deg_c], 15.0, 0.1, 40.0)
	}

	oair.par_group("Mixing parameters") {
		attn0  : par_real("Diffuse attenuation coefficent (clear water)", [m -1], 0.2, 0.01, 1)
		
		N0     : par_real("Brunt-Väisälä frequency reference", [s-1], 0.8e-2)
		Nmin   : par_real("Minimum B-V frequency", [s-1], 1e-4, 1e-10, 0.1)
		K0     : par_real("Mixing factor reference", [m 2, s-1], 0.5e-4, "Mixing factor at the B-V frequency reference")
		alpha  : par_real("Mixing non-linear coefficient", [], 1.4)
		
		# TODO: Find correct defaults:
		Es0    : par_real("Surface additional mixing energy", [m 2, s-3], 0)
		zshalf : par_real("Halving depth of additional mixing energy", [m], 3)
		hsfact : par_real("Diminishing rate of additional mixing energy", [m], 4)
	}
	
	sed.par_group("Sediment parameters") {
		T_sed  : par_real("Deep sediment temperature", [deg_c], 4)
		dz_sed : par_real("Depth of thermally active sediment layer", [m], 10)
		k_sed  : par_real("Sediment thermal conductivity", [W, m-1, K-1], 1.3)
		C_sed  : par_real("Sediment specific heat capacity", [J, k g-1, K-1], 4000)
		rho_sed : par_real("Sediment density", [k g, m-3], 2600)
		#TODO: porosity
	}
	
	
	layer.has(dz : property("Thickness"), [m]) {
		1[m]   # Will maybe dynamic eventually
	} #.initial { 1[m] }
	
	layer.has(z : property("Depth"), [m]) {
		above(vert, z) + above(vert, dz)
	}
	
	layer.has(water, [k g], "Layer water") .initial { A*dz*rho_water }   #TODO: temperature adjust
	
	layer.water.has(salt, [k g], [g, k g-1], "Layer salt") .initial_conc { init_S }
	
	layer.water.has(heat, [J], "Layer thermal energy") .initial_conc { C_water * (init_T->[K]) }   #TODO: C_water should at least be salinity dependent

	layer.water.has(temp, [deg_c], "Layer temperature") {
		heat / (water*C_water) -> [deg_c]
	}
	
	layer.water.has(dens : property("Density"), [k g, m-3], "Potential density") {
		salinity := conc(salt)=>[] # TODO: Convert salinity to PSU
		seawater_pot_dens(temp, salinity)
	}
	
	layer.water.has(accum_pressure : property("Accumulated pressure"), [Pa]) {
		above(vert, accum_pressure) + dens*grav*dz
	}
	
	layer.water.has(pressure, [Pa]) {
		accum_pressure + air.pressure->[Pa]
	}
	
	layer.water.has(ddens : property("d(dens)"), [k g, m-3]) {
		(below(vert, dens)-dens)
		#0.5*(below(vert, dens)-above(vert, dens))
		#(dens - above(vert, dens))
	}
	
	layer.water.has(Nfreq : property("Brunt-Väisälä frequency"), [s-1]) {
		mdz := 0.5*(dz + below(vert, dz))
		N2 := grav * ddens / (mdz*dens)
		sqrt(max(Nmin^2, N2))
	}
	
	layer.water.has(Kt : property("Tide wave mixing coefficient"), [m 2, s-1]) {
		safe_divide(K0, (Nfreq/N0)^alpha)
	}
	
	layer.water.has(Ks : property("Additional mixing coefficient"), [m 2, s-1]) {
		eta := exp(-(z - zshalf)/hsfact)
		Es  := Es0*eta/(1+eta)
		Es / Nfreq^2
	}
	
	layer.water.has(wmix : property("Water mixing"), [k g, day-1]) {
		K := Kt + Ks + Kw#+Kd
		dens * A * K / dz ->>
	}
	
	oair.has(stress : property("Wind stress"), [N, m-2]) {
		u := air.wind
		c_stress := 1e-3*(0.8 + 0.9*u^8/(u^8 + 1e8[m 8, s-8]))
		air.dens*c_stress*u^2
	}
	
	#oair.has(friction : property("Wind friction speed"), [m, s-1]) {
	#	sqrt(stress/top(vert, layer.water.dens))
	#}
	
	#TODO: need to take into account of B_s in the fjord model document
	oair.has(emix : property("Wind mixing energy"), [J], "Total wind mixing energy") {
		#m0 := 0.5
		#m0*friction^3
		top(vert, A)*sqrt(stress^3/top(vert, layer.water.dens))*time.step_length_in_seconds
	}
	
	layer.water.has(sumV : property("Sum V above"), [m 3]) {
		above(vert, sumV) + above(vert, A)*above(vert, dz)
	}
	
	layer.water.has(potmix : property("Potential energy needed for wind mixing"), [J]) {
		max(0, grav*ddens*(sumV*A*dz/(sumV + A*dz))*((z+0.5*dz)/2))
	}
	
	layer.water.has(emix, [J]) {
		rem := max(0, oair.emix - summix)
		min(rem, potmix)
	}
	
	layer.water.has(summix : property("Sum used wind mixing energy"), [J]) {
		above(vert, emix) + above(vert, summix)
	}
	
	layer.water.has(Kw : property("Wind mixing coefficient"), [m 2, s-1]) {
		#TODO: Find out why we get the alternating bands!!
		
		rem := max(0, oair.emix - summix)
		# This one is a bit iffy..
		mixspeed := 1[m, day-1]
		
		mixspeed*dz->>                                                    if rem > 0 & potmix < 1e-20[J],
		mixspeed*dz*safe_divide(below(vert, emix),below(vert, potmix))->> otherwise
		#mixspeed*dz->>                                                    otherwise
	}
	
	flux(layer.water, vert, "Water mixing down") { wmix }
	flux(layer.water, vert, "Water mixing up") { -wmix }

	tracer : quantity("Tracer")
	layer.water.has(tracer, [k g])
	
	flux(nowhere, layer.water.tracer, vert, "Tracer input") .top {
		1[k g, day-1]
	}
	
	flux(layer.water.tracer, nowhere, vert, "Tracer vanishes") .bottom {
		bottom(tracer)*0.3[day-1]
	}
	
	# Air-sea :
	
	lwd : property("Downwelling longwave radiation")
	a_hum : property("Actual specific humidity")
	
	
	oair.has(stab : property("Surface stability"), []) {
		surface_stability(air.wind, top(vert, layer.water.temp), air.temp)
	}
	
	oair.has(ced : property("Transfer coefficient for latent heat flux"), []) {
		tc_latent_heat(air.wind, stab)
	}
	
	oair.has(chd : property("Transfer coefficent for sensible heat flux"), []) {
		tc_sensible_heat(air.wind, stab)
	}
	
	oair.has(s_hum : property("Saturation specific humidity"), []) {
		svap := saturation_vapor_pressure(top(vert, layer.water.temp))
		specific_humidity_from_pressure(air.pressure, svap)
	}
	
	oair.has(lwu : property("Emitted longwave radiation"), [W, m-2]) {
		emissivity := 0.98
		emissivity * black_body_radiation(top(vert, layer.water.temp)->[K])
	}

	flux(nowhere, layer.water.heat, vert, "Net longwave") .top {
		top(A) * (air.lwd - oair.lwu) ->>
	}
	
	flux(nowhere, layer.water.heat, vert, "Latent heat flux") .top {
		l_vap := latent_heat_of_vaporization(top(temp))
		top(A) * (oair.ced * l_vap * air.dens * air.wind * (air.a_hum - oair.s_hum)) ->>
	}
	
	flux(nowhere, layer.water.heat, vert, "Sensible heat flux") .top {
		top(A) * (oair.chd * C_air * air.dens * air.wind * (air.temp->[K] - top(temp)->[K])) ->>
	}
	
	layer.water.has(attn : property("Diffuse attenuation coefficent"), [m-1]) {
		attn0  #TODO: Correct for chl-a or things like that. Probably needs to be in separate module.
	}
	
	sw_vert : connection("Shortwave vertical", grid1d) { layer* }
	
	flux(nowhere, layer.water.heat, sw_vert, "Net shortwave") .top {
		albedo := 0.045
		top(A) * (1 - albedo) * air.g_rad ->>
	}
	
	flux(layer.water.heat, sw_vert, "Shortwave shine-through") {
		in_flux(sw_vert, heat) * exp(-attn*dz) * below(vert, A) / A
	}
	
	sed.has(heat, [J], "Sediment heat") .initial {
		mass := bottom(vert, A)*dz_sed*rho_sed
		C_sed * mass * (T_sed->[K])
	}
	
	sed.has(temp, [deg_c], "Sediment surface temperature") {
		mass := bottom(vert, A)*dz_sed*rho_sed
		1*(2*heat / (mass*C_sed) - T_sed->[K]) -> [deg_c]
	}
	
	# Water-Sediment heat transfer
	
	flux(layer.water.heat, sed.heat, vert, "Water-sediment heat transfer") .bottom {
		dz := dz_sed*0.2  # Just the scaling factor for the transfer TODO: get a better estimate
		bottom(A)*(bottom(temp)->[K] - sed.temp->[K])*k_sed/dz ->>
	}
	
	
}

module("NIVAFjord", 0, 0, 1) {

	load("../../stdlib/physiochemistry.txt", library("Water utils"), library("Basic constants"))
	load("../../stdlib/seawater.txt", library("Seawater"))

	layer : compartment("Fjord layer")
	
	water : quantity("Water")
	salt  : quantity("Salt")
	heat  : quantity("Thermal energy")
	
	temp : property("Temperature")
	
	vert : connection("Fjord vertical", grid1d) { layer* }
	
	layer.par_group("Layer parameters") {
		A      : par_real("Layer area", [m 2], 10000, 0, 1e6)
		init_S : par_real("Initial salinity", [g, k g-1], 35.0, 20.0, 50.0)
		init_T : par_real("Initial temperature", [deg_c], 15.0, 0.1, 40.0)
	}
	
	# TODO: Should be attached to fjord arm, not to layer
	layer.par_group("Fjord arm parameters") {
		N0     : par_real("Brunt-Väisälä frequency reference", [s-1], 0.8e-2)
		Nmin   : par_real("Minimum B-V frequency", [s-1], 1e-4, 1e-10, 0.1)
		K0     : par_real("Mixing factor reference", [m 2, s-1], 0.5e-4, "Mixing factor at the frequency reference")
		alpha  : par_real("Mixing non-linear coefficient", [], 1.4)
	}
	
	layer.has(z : property("Thickness"), [m]) {
		1[m]   # Will be dynamic eventually
	} .initial { 1[m] }
	
	layer.has(water, [k g], "Layer water") .initial { A*z*rho_water }   #TODO: temperature adjust
	
	layer.water.has(salt, [k g], [g, k g-1], "Layer salt") .initial_conc { init_S }
	
	layer.water.has(heat, [J], "Layer thermal energy") .initial_conc { C_water * (init_T->[K]) }   #TODO: C_water should at least be salinity dependent

	layer.water.has(temp, [deg_c], "Layer temperature") {
		heat / (water*C_water) -> [deg_c]
	}
	
	layer.water.has(dens : property("Potential density"), [k g, m-3]) {
		salinity := conc(salt)=>[] # TODO: Convert salinity to PSU
		seawater_pot_dens(temp, salinity)
	}
	
	#layer.water.has(ddens : property("d(dens)/dz"), [k g, m-4]) {
	#	dz := 0.5*(z + target(vert, z))
	#	(dens - target(vert, dens)) / dz
	#}
	
	layer.water.has(Kdiff : property("Mixing coefficient"), [m 2, s-1]) {
		dz := 0.5*(z + target(vert, z))
		ddens := (target(vert, dens) - dens) / dz
		N2 := g * ddens / dens
		N := sqrt(max(Nmin^2, N2))
		K0 * (N/N0)^(-alpha)
	}
	
	layer.water.has(wmix : property("Water turbulent mixing"), [k g, day-1]) {
		# TODO: Is it necessary to do the means here??
		#Kd := 0.5*(Kdiff + target(vert, Kdiff))
		#dz := 0.5*(z + target(vert, z))
		#a :=  0.5*(A + target(vert, A))
		#rho := 0.5*(dens + target(vert, dens))
		#rho * a * Kd / dz ->>
		dens * A * Kdiff / z ->>
	}
	
	# Negative fluxes don't work properly for dissolved ones... TODO: Fix!
	#flux(layer.water, vert, "Turbulent mixing down") { wmix }
	#flux(layer.water, vert, "Turbulent mixing up") { -wmix }
	
	flux(layer.water.heat, vert, "Temperature turbulent mixing") {
		wmix * (conc(heat) - target(conc(heat)))
	}
	
	flux(layer.water.salt, vert, "Salt turbulent mixing") {
		wmix * (conc(salt) - target(conc(salt))) ->>
	}
}
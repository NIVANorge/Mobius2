
module("NIVAFjord", 0, 0, 1) {

	load("../../stdlib/physiochemistry.txt", library("Water utils"), library("Basic constants"), library("Thermodynamics"))
	load("../../stdlib/seawater.txt", library("Seawater"), library("Air-sea"))
	load("../../stdlib/atmospheric.txt", library("Meteorology"), library("Radiation"))

	air   : compartment("Atmosphere")
	oair  : compartment("Ocean air")   # Air right above a given ocean section. Better name?
	layer : compartment("Fjord layer")
	sed   : compartment("Fjord sediment")
	
	water : quantity("Water")
	salt  : quantity("Salt")
	heat  : quantity("Thermal energy")
	
	temp : property("Temperature")
	
	# TODO: Common atmospheric module!
	air.has(temp,      [deg_c], "Air temperature")
	#air.has(precip,    [m m, day-1])
	air.has(wind     : property("Wind speed"),        [m, s-1])
	air.has(r_hum    : property("Relative humidity"), [])
	air.has(pressure : property("Pressure"),          [h Pa], "Air pressure")
	air.has(cloud    : property("Cloud cover"),       [])
	air.has(g_rad    : property("Global radiation"),  [W, m-2])
	
	
	vert : connection("Fjord vertical", grid1d) { layer* }
	
	layer.par_group("Layer parameters") {
		A      : par_real("Layer area", [m 2], 10000, 0, 1e6)
		init_S : par_real("Initial salinity", [g, k g-1], 35.0, 20.0, 50.0)
		init_T : par_real("Initial temperature", [deg_c], 15.0, 0.1, 40.0)
	}

	oair.par_group("Mixing parameters") {
		attn0  : par_real("Diffuse attenuation coefficent (clear water)", [m -1], 0.2, 0.01, 1)
		
		N0     : par_real("Brunt-Väisälä frequency reference", [s-1], 0.8e-2)
		Nmin   : par_real("Minimum B-V frequency", [s-1], 1e-4, 1e-10, 0.1)
		K0     : par_real("Mixing factor reference", [m 2, s-1], 0.5e-4, "Mixing factor at the B-V frequency reference")
		alpha  : par_real("Mixing non-linear coefficient", [], 1.4)
		c_stress : par_real("Wind friction coefficient", [], 1)
	}
	
	sed.par_group("Sediment parameters") {
		T_sed  : par_real("Deep sediment temperature", [deg_c], 4)
		dz_sed : par_real("Depth of thermally active sediment layer", [m], 10)
		k_sed  : par_real("Sediment thermal conductivity", [W, m-1, K-1], 1.6)
		C_sed  : par_real("Sediment specific heat capacity", [J, k g-1, K-1], 4000)
		rho_sed : par_real("Sediment density", [k g, m-3], 2600)
		#TODO: porosity
	}
	
	
	layer.has(dz : property("Thickness"), [m]) {
		1[m]   # Will maybe dynamic eventually
	} #.initial { 1[m] }
	
	#layer.has(z : property("Depth"), [m]) {
	#	above(vert, z) + above(vert, dz)
	#}
	
	layer.has(water, [k g], "Layer water") .initial { A*dz*rho_water }   #TODO: temperature adjust
	
	layer.water.has(salt, [k g], [g, k g-1], "Layer salt") .initial_conc { init_S }
	
	layer.water.has(heat, [J], "Layer thermal energy") .initial_conc { C_water * (init_T->[K]) }   #TODO: C_water should at least be salinity dependent

	layer.water.has(temp, [deg_c], "Layer temperature") {
		heat / (water*C_water) -> [deg_c]
	}
	
	layer.water.has(dens : property("Density"), [k g, m-3], "Potential density") {
		salinity := conc(salt)=>[] # TODO: Convert salinity to PSU
		seawater_pot_dens(temp, salinity)
	}
	
	layer.water.has(ddens : property("d(dens)/dz"), [k g, m-3]) {
		(below(vert, dens)-dens)
		#2*(below(vert, dens)-above(vert, dens))
		#(dens - above(vert, dens))
	}
	
	layer.water.has(Kt : property("Tide wave mixing coefficient"), [m 2, s-1]) {
		mdz := 0.5*(dz + below(vert, dz))
		N2 := grav * ddens / (mdz*dens)
		N := sqrt(max(Nmin^2, N2))
		K0 * (N/N0)^(-alpha)
	}
	
	layer.water.has(wmix : property("Water mixing"), [k g, day-1]) {
		dens * A * Kt / dz ->>
	}
	
	oair.has(stress : property("Wind stress"), [N, m-2]) {
		air.dens*c_stress*air.wind^2
	}
	
	oair.has(friction : property("Wind friction speed"), [m, s-1]) {
		sqrt(stress/top(vert, layer.water.dens))
	}
	
	#TODO: need to take into account of B_s in the fjord model document
	oair.has(emix : property("Mixing energy"), [m 3, s-3], "Total wind mixing energy") {
		m0 := 0.5
		m0*friction^3
	}
	
	# layer.water.has(emix, [m 3, s-3]) {
		# maxspeed := air.wind #Hmm...
		# J := maxspeed*grav*ddens*dz/dens # Energy needed to mix the layer at max speed
		# rem := oair.emix - above(vert, summix)        # Remaining available.
		# min(rem, J)
	# }
	
	# layer.water.has(summix : property("Sum used wind mixing energy"), [m 3, s-3]) {
		# above(vert, summix) + emix
	# }
	
	# layer.water.has(Kw : property("Wind mixing coefficient"), [m 2, s-1]) {
		# emix*dens/(grav*ddens)
	# }
	
	# Negative fluxes don't work properly for dissolved ones... TODO: Fix!
	#flux(layer.water, vert, "Turbulent mixing down") { wmix }
	#flux(layer.water, vert, "Turbulent mixing up") { -wmix }
	
	flux(layer.water.heat, vert, "Heat mixing") {
		wmix * (conc(heat) - below(conc(heat)))
	}
	
	flux(layer.water.salt, vert, "Salt mixing") {
		wmix * (conc(salt) - below(conc(salt))) ->>
	}
	
	
	# Air-sea :
	
	#TODO: Some of this stuff should be in atmospheric module and be reused between nivafjord and easylake (and maybe pet)
	
	oair.has(stab : property("Surface stability"), []) {
		surface_stability(air.wind, top(vert, layer.water.temp), air.temp)
	}
	
	oair.has(ced : property("Transfer coefficient for latent heat flux"), []) {
		tc_latent_heat(air.wind, stab)
	}
	
	oair.has(chd : property("Transfer coefficent for sensible heat flux"), []) {
		tc_sensible_heat(air.wind, stab)
	}
	
	air.has(a_vap : property("Actual vapor pressure"), [h Pa]) {
		svap := saturation_vapor_pressure_lowe(air.temp)
		air.r_hum * 0.01 * svap  # 0.01 to convert percent to true dimensionless. Maybe perc should be a unit equal to [100] so that it gets proper checking?
	}
	
	oair.has(s_hum : property("Saturation specific humidity"), []) {
		svap := saturation_vapor_pressure_lowe(top(vert, layer.water.temp))
		specific_humidity_from_pressure(air.pressure, svap)
	}
	
	air.has(a_hum : property("Actual specific humidity"), []) {
		specific_humidity_from_pressure(air.pressure, air.a_vap)
	}
	
	air.has(dens, [k g, m-3], "Air density") {
		air_density(temp, pressure, a_vap)
	}
	
	air.has(lwd : property("Downwelling longwave radiation"), [W, m-2]) {
		downwelling_longwave(air.temp, a_vap, cloud)
	}
	
	oair.has(lwu : property("Emitted longwave radiation"), [W, m-2]) {
		emissivity := 0.98
		emissivity * black_body_radiation(top(vert, layer.water.temp)->[K])
	}

	flux(nowhere, layer.water.heat, vert, "Net longwave") .top {
		top(A) * (air.lwd - oair.lwu) ->>
	}
	
	flux(nowhere, layer.water.heat, vert, "Latent heat flux") .top {
		l_vap := latent_heat_of_vaporization(top(temp))
		top(A) * (oair.ced * l_vap * air.dens * air.wind * (air.a_hum - oair.s_hum)) ->>
	}
	
	flux(nowhere, layer.water.heat, vert, "Sensible heat flux") .top {
		top(A) * (oair.chd * C_air * air.dens * air.wind * (air.temp->[K] - top(temp)->[K])) ->>
	}
	
	layer.water.has(attn : property("Diffuse attenuation coefficent"), [m-1]) {
		attn0  #TODO: Correct for chl-a or things like that. Probably needs to be in separate module.
	}
	
	sw_vert : connection("Shortwave vertical", grid1d) { layer* }
	
	flux(nowhere, layer.water.heat, sw_vert, "Net shortwave") .top {
		albedo := 0.045
		top(A) * (1 - albedo) * air.g_rad ->>
	}
	
	flux(layer.water.heat, sw_vert, "Shortwave shine-through") {
		in_flux(sw_vert, heat) * exp(-attn*dz)
	}
	
	sed.has(heat, [J], "Sediment heat") .initial {
		mass := bottom(vert, A)*dz_sed*rho_sed
		C_sed * mass * (T_sed->[K])
	}
	
	sed.has(temp, [deg_c], "Sediment surface temperature") {
		mass := bottom(vert, A)*dz_sed*rho_sed
		1*(2*heat / (mass*C_sed) - T_sed->[K]) -> [deg_c]
	}
	
	# Water-Sediment heat transfer
	
	flux(layer.water.heat, sed.heat, vert, "Water-sediment heat transfer") .bottom {
		dz := dz_sed*0.2  # Just the scaling factor for the transfer TODO: get a better estimate
		bottom(A)*(bottom(temp)->[K] - sed.temp->[K])*k_sed/dz ->>
	}
	
	
}
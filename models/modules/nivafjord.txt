
module("NIVAFjord", 0, 0, 1) {

	load("stdlib/basic_math.txt", library("Basic"), library("Response"))
	load("stdlib/physiochemistry.txt", library("Water utils"), library("Basic constants"), library("Thermodynamics"))
	load("stdlib/seawater.txt", library("Seawater"), library("Air-sea"))
	load("stdlib/atmospheric.txt", library("Meteorology"))#, library("Radiation"))

	air   : compartment("Atmosphere")
	oair  : compartment("Ocean-air interface")
	layer : compartment("Fjord layer")
	sed   : compartment("Fjord sediment")
	bnd   : compartment("Boundary ocean")
	bnd_layer : compartment("Boundary layer")
	
	water : quantity("Water")
	salt  : quantity("Salt")
	heat  : quantity("Thermal energy")
	
	temp     : property("Temperature")
	pressure : property("Pressure")
	wind     : property("Wind speed")
	g_rad    : property("Global radiation")

	var(air.temp,  [deg_c], "Air temperature")
	var(air.wind,  [m, s-1])
	var(air.g_rad, [W, m-2])
	
	
	vert : connection("Fjord vertical", grid1d) { layer* }
	
	par_group("Fjord global parameters") {
		dz     : par_real("Layer thickness", [m], 1, 0.1, 5) # TODO: Just make it a universal param?
	}
	
	layer.par_group("Layer parameters") {
		A      : par_real("Layer area", [m 2], 10000, 0, 1e6)
		w_bnd  : par_real("Width to boundary", [m], 0, 0, 10000)
		#init_S : par_real("Initial salinity", [g, k g-1], 35, 20, 50)
		#init_T : par_real("Initial temperature", [deg_c], 5, 0.1, 40)
	}

	oair.par_group("Mixing parameters") {
		attn0  : par_real("Diffuse attenuation coefficent (clear water)", [m -1], 0.2, 0.01, 1)
		
		N0     : par_real("Brunt-Väisälä frequency reference", [s-1], 0.8e-2)
		Nmin   : par_real("Minimum B-V frequency", [s-1], 1e-4, 1e-10, 0.1)
		K0     : par_real("Mixing factor reference", [m 2, s-1], 0.5e-4, "Mixing factor at the B-V frequency reference")
		alpha  : par_real("Mixing non-linear coefficient", [], 1.4)
		
		# TODO: Find correct defaults:
		Es0    : par_real("Surface additional mixing energy", [m 2, s-3], 0)
		zshalf : par_real("Halving depth of additional mixing energy", [m], 3)
		hsfact : par_real("Diminishing rate of additional mixing energy", [m], 4)
		
		alpha_u : par_real("Pressure difference mixing coefficient", [], 0.5, 0.1, 1)
	}
	
	# TODO: There should be a sediment compartment per layer instead..
	sed.par_group("Sediment parameters") {
		T_sed  : par_real("Deep sediment temperature", [deg_c], 4)
		dz_sed : par_real("Depth of thermally active sediment layer", [m], 10)
		k_sed  : par_real("Sediment thermal conductivity", [W, m-1, K-1], 1.3)
		C_sed  : par_real("Sediment specific heat capacity", [J, k g-1, K-1], 4000)
		rho_sed : par_real("Sediment density", [k g, m-3], 2600)
		#TODO: porosity
	}
	
	z : property("Depth (nominal)")
	
	var(layer.z, [m]) {
		z[vert.above] + dz[vert.above]
	}
	
	var(layer.water, [k g], "Layer water") .override { A*dz*rho_water }
	
	var(layer.water.salt, [k g], [g, k g-1], "Layer salt")
		#.initial_conc { init_S }
		.initial_conc { bnd_layer.water.salinity =>> } #TODO: convert PSU to conc
	
	var(layer.water.heat, [J], "Layer thermal energy") 
		#.initial_conc { C_water * (init_T->[K]) }   #TODO: C_water should at least be salinity dependent
		.initial_conc { C_water * (temp -> [K]) }

	var(layer.water.temp, [deg_c], "Layer temperature") {
		heat / (water*C_water) -> [deg_c]      #TODO: C_water should at least be salinity dependent
	} .initial {
		bnd_layer.water.temp
	}
	
	salinity : property("Salinity")
	var(layer.water.salinity, [], "Layer salinity") {
		conc(salt)=>[] # TODO: Convert salinity to PSU
	}
	
	dens : property("Density") {
		seawater_pot_dens(temp, salinity)
	}
	
	var(layer.water.dens, [k g, m-3], "Potential density")
	
	# TODO: When we make a change so that accessing vert.above does not zero out the entire equation, we won't need this one.
	layer.water.has(above_p : property("Above pressure"), [Pa]) {    accum_pressure[vert.above]   }
	
	accum_pressure : property("Accumulated pressure")
	ddens          : property("d(dens)")
	Nfreq          : property("Brunt-Väisälä frequency")
	Kt             : property("Tide wave mixing coefficient")
	Ks             : property("Additional mixing coefficient")
	Kw             : property("Wind mixing coefficient")
	wmix           : property("Water mixing")
	
	var(layer.water.accum_pressure, [Pa]) {
		above_p + dens*grav*dz
	}
	
	var(layer.water.ddens, [k g, m-3]) {
		(dens[vert.below]-dens)
		#0.5*(below(vert, dens)-above(vert, dens))
		#(dens - above(vert, dens))
	}
	
	var(layer.water.Nfreq, [s-1]) {
		mdz := 0.5*(dz + dz[vert.below])
		N2 := grav * ddens / (mdz*dens)
		sqrt(max(Nmin^2, N2))
	}
	
	var(layer.water.Kt, [m 2, s-1]) {
		safe_divide(K0, (Nfreq/N0)^alpha)
	}
	
	var(layer.water.Ks, [m 2, s-1]) {
		eta := exp(-(z - zshalf)/hsfact)
		Es  := Es0*eta/(1+eta)
		Es / Nfreq^2
	}
	
	var(layer.water.wmix : property("Water mixing"), [k g, day-1]) {
		K := Kt + Ks + Kw#+Kd
		dens * A * K / dz ->>
	}
	
	stress         : property("Wind stress")
	emix           : property("Wind mixing energy")
	sumV           : property("Sum V above")
	potmix         : property("Potential energy needed for wind mixing")
	summix         : property("Sum used wind mixing energy")
	
	var(oair.stress, [N, m-2]) {
		u := air.wind
		c_stress := 1e-3*(0.8 + 0.9*u^8/(u^8 + 1e8[m 8, s-8]))
		air.dens*c_stress*u^2
	}
	
	#TODO: need to take into account of B_s in the fjord model document (?)
	var(oair.emix, [J], "Total wind mixing energy") {
		A[vert.top]*sqrt(stress^3/layer.water.dens[vert.top])*time.step_length_in_seconds
	}
	
	var(layer.water.sumV, [m 3]) {
		sumV[vert.above] + A[vert.above]*dz[vert.above]
	}
	
	var(layer.water.potmix, [J]) {
		max(0, grav*ddens*(sumV*A*dz/(sumV + A*dz))*((z+0.5*dz)/2))
	}
	
	var(layer.water.emix, [J]) {
		rem := max(0, oair.emix - summix)
		min(rem, potmix)
	}
	
	layer.water.has(summix : property("Sum used wind mixing energy"), [J]) {
		emix[vert.above] + summix[vert.above]
	}
	
	var(layer.water.Kw, [m 2, s-1]) {
		#TODO: Find out why we get the alternating bands!!
		
		rem := max(0, oair.emix - summix)
		# This one is a bit iffy..
		mixspeed := 1[m, day-1]
		
		mixspeed*dz->>                                                    if rem > 0 & potmix < 1e-20[J],
		mixspeed*dz*safe_divide(emix[vert.below], potmix[vert.below])->> otherwise
		#mixspeed*dz->>                                                    otherwise
	}
	
	flux(layer.water, vert, [k g, day-1], "Water mixing down") { wmix }
	flux(layer.water, vert, [k g, day-1], "Water mixing up") { -wmix }

	tracer : quantity("Tracer")
	var(layer.water.tracer, [k g])
	
	/*
	flux(nowhere, layer.water.tracer[vert.top], [k g, day-1], "Tracer input") {
		1[k g, day-1]
	}
	
	flux(layer.water.tracer[vert.bottom], nowhere, [k g, day-1], "Tracer vanishes") {
		tracer[bottom]*0.3[day-1]
	}
	*/
	
	# Air-sea :
	
	lwd : property("Downwelling longwave radiation")
	a_hum : property("Actual specific humidity")
	stab : property("Surface stability")
	ced : property("Transfer coefficient for latent heat flux")
	chd : property("Transfer coefficent for sensible heat flux")
	s_hum : property("Saturation specific humidity")
	lwu : property("Emitted longwave radiation")
	
	var(oair.stab, []) {
		surface_stability(air.wind, layer.water.temp[vert.top], air.temp)
	}
	
	var(oair.ced, []) {
		tc_latent_heat(air.wind, stab)
	}
	
	var(oair.chd, []) {
		tc_sensible_heat(air.wind, stab)
	}
	
	var(oair.s_hum, []) {
		svap := saturation_vapor_pressure(layer.water.temp[vert.top])
		specific_humidity_from_pressure(air.pressure, svap)
	}
	
	var(oair.lwu, [W, m-2]) {
		emissivity := 0.98
		emissivity * black_body_radiation(layer.water.temp[vert.top]->[K])
	}

	flux(nowhere, layer.water.heat[vert.top], [J, day-1], "Net longwave") {
		A[top] * (air.lwd - oair.lwu) ->>
	}
	
	flux(nowhere, layer.water.heat[vert.top], [J, day-1], "Latent heat flux") {
		l_vap := latent_heat_of_vaporization(temp[top])
		A[top] * (oair.ced * l_vap * air.dens * air.wind * (air.a_hum - oair.s_hum)) ->>
	}
	
	flux(nowhere, layer.water.heat[vert.top], [J, day-1], "Sensible heat flux") {
		A[top] * (oair.chd * C_air * air.dens * air.wind * (air.temp->[K] - temp[top]->[K])) ->>
	}
	
	attn : property("Diffuse attenuation coefficent")
	
	var(layer.water.attn, [m-1]) {
		attn0  #TODO: Correct for chl-a or things like that. Probably needs to be in separate module.
	}
	
	sw_vert : connection("Shortwave vertical", grid1d) { layer* }
	
	flux(nowhere, layer.water.heat[sw_vert.top], [J, day-1], "Net shortwave")  {
		albedo := 0.045
		A[top] * (1 - albedo) * air.g_rad ->>
	}
	
	flux(layer.water.heat, sw_vert, [J, day-1], "Shortwave shine-through") {
		(in_flux(sw_vert, heat)->[J, day-1]) * exp(-attn*dz) * A[vert.below] / A
	}
	
	var(sed.heat, [J], "Sediment heat") .initial {
		mass := A[vert.bottom]*dz_sed*rho_sed
		C_sed * mass * (T_sed->[K])
	}
	
	var(sed.temp, [deg_c], "Sediment surface temperature") {
		mass := A[vert.bottom]*dz_sed*rho_sed
		1*(2*heat / (mass*C_sed) - T_sed->[K]) -> [deg_c]
	}
	
	# Water-Sediment heat transfer
	
	flux(layer.water.heat[vert.bottom], sed.heat, [J, day-1], "Water-sediment heat transfer") {
		dz := dz_sed*0.2  # Just the scaling factor for the transfer TODO: get a better estimate
		A[bottom]*(temp[bottom]->[K] - sed.temp->[K])*k_sed/dz ->>
	}
	
	
	
	# Horizontal exchange with boundary
	
	
	z1       : property("Epilimnion thickness")
	z2diff   : property("log10(Metalimnion thickness)")
	temp_top : property("Temperature top")
	temp_bot : property("Temperature bottom")
	sal_top  : property("Salinity top")
	sal_bot  : property("Salinity bottom")
	trac_top : property("Tracer top")
	trac_bot : property("Tracer bot")
	
	var(bnd.z1, [m])
	var(bnd.z2diff, [])
	var(bnd.temp_top, [deg_c])
	var(bnd.temp_bot, [deg_c])
	var(bnd.sal_top, [])
	var(bnd.sal_bot, [])
	
	var(bnd.trac_top, [])
	var(bnd.trac_bot, [])

	bnd_vert : connection("Boundary vertical", grid1d) { bnd_layer* }
	
	var(bnd_layer.z, [m]) {
		z[bnd_vert.above] + dz
	}
	
	prof : property("Boundary profile")
	
	var(bnd_layer.prof, []) {
		z1 := bnd.z1
		z2 := (10^bnd.z2diff)=>[m] + z1
		a := {
			((z2-z)/(z2-z1))^2   if z < z2,
			0                    otherwise
		}
		b := {
			0                    if z < z1,
			((z-z1)/z1)^1.5      otherwise
		}
		g := a / (z/z1 + a^4)^(1/4.)
		h := b / sqrt(1 + b^2)
		(1 - g + h)/2
	}
	
	var(bnd_layer.water.tracer, [k g], "Boundary layer tracer") .override_conc {
		lerp(prof, 0, 1, bnd.trac_top, bnd.trac_bot)
	}
	
	var(bnd_layer.water, [k g], "Boundary layer water") .override { 1[k g] }   # This is just so that it can have a concentration of various things, for automatic flux generation to work.
	
	var(bnd_layer.water.temp, [deg_c], "Boundary layer temperature") {  lerp(prof, 0, 1, bnd.temp_top, bnd.temp_bot)  }
	
	var(bnd_layer.water.salinity, [], "Boundary layer salinity") {  lerp(prof, 0, 1, bnd.sal_top, bnd.sal_bot)  }
	
	var(bnd_layer.water.heat, [J], "Boundary layer heat") .override_conc {
		(temp->[K]) * C_water
	}
	
	var(bnd_layer.water.salt, [k g], [g, k g-1], "Boundary layer salt") .override_conc {
		salinity =>> #TODO: proper conversion from PSU
	}
	
	var(bnd_layer.water.dens, [k g, m-3], "Boundary layer density")
	
	# NOTE: see earlier use of above_p
	var(bnd_layer.water.above_p, [Pa]) {    accum_pressure[bnd_vert.above]   }
	
	var(bnd_layer.water.accum_pressure, [Pa]) {
		above_p + dens*grav*dz
	}
	
	barocline_bnd_u : property("Barocline boundary flux")
	
	var(layer.water.barocline_bnd_u, [k g, s-1]) {
		dP := accum_pressure[vert.below] - bnd_layer.water.accum_pressure[vert.below]
		
		u := copysign(sqrt(2*alpha_u*abs(dP)/rho_water), dP)
		u * w_bnd * dz * rho_water
	}
	
	h : quantity("Sea level") # Could probably be made a property then..
	
	sealevel_component : function(amp : [c m], phase : [deg], per : [hr], t : [hr]) {
		amp * cos( (pi/180[deg])*(t*360[deg]/per - phase) )
	}
	
	sealevel : function(t : [hr]) {
		# TODO: Parametrize. This in particular is for Oscarsborg.
		  sealevel_component(11.2[c m], 282[deg], 365.24*24[hr], t)
		+ sealevel_component(13.4[c m], 152[deg], 12.42[hr], t)
		+ sealevel_component( 3.4[c m], 101[deg], 12.00[hr], t)
		+ sealevel_component( 3.3[c m], 101[deg], 12.66[hr], t)
		+ sealevel_component( 0.9[c m],  76[deg], 11.97[hr], t)
		+ sealevel_component( 0.5[c m], 172[deg], 23.93[hr], t)
		+ sealevel_component( 2.1[c m], 299[deg], 15.82[hr], t)
	}
	
	var(bnd.h, [m]) .override {
		sec := time.second_of_day + time.step_length_in_seconds * time.fractional_step
		sealevel(sec->[hr])->[m]              
	}
	
	#TODO: The barotropic flow must probably be limited to the max pressure-induced flow. In that case the value for h must be updated according to that.
	#	Only relevant in very narrow passages though.
	
	w_bnd_ : property("Width to boundary")
	A_bnd : property("Total area to boundary")
	tot_barotropic_u : property("Total barotropic boundary flux")
	barotropic_bnd_u : property("Barotropic boundary flux")
	horz_target : property("Target of horizontal flux")
	
	var(layer.w_bnd_ : property("Width to boundary"), [m]) { w_bnd	} # Since we cant aggregate() a parameter yet.
	
	var(oair.A_bnd, [m 2]) { aggregate(layer.w_bnd_)*dz }
	
	var(oair.h, [m]) .override { bnd.h } #+ (in_flux(downstream, water)/A_bnd)^2/(2*alpha_u*grav) }# TODO: different with river inflow.
	
	var(oair.tot_barotropic_u, [m 3, s-1]) {
		-(h - last(h))*A[vert.top]/time.step_length_in_seconds
	}
	
	var(layer.water.barotropic_bnd_u, [k g, s-1]) {
		#0[m 3, s-1] #TODO.
		oair.tot_barotropic_u * w_bnd * dz * rho_water / oair.A_bnd
	}
	
	var(layer.water.horz_target, [])
	
	special_computation("Place horizontal fluxes", "nivafjord_place_horizontal_fluxes", layer.water.horz_target) {
		bnd_layer.water.dens
		layer.water.dens
		w_bnd
	}
	
	#/*

	flux(layer.water, nowhere, [k g, day-1], "Flow from boundary equivalent removal") {
		bcl := -(barocline_bnd_u + barotropic_bnd_u)->>
		bcl    if bcl > 0,
		0      otherwise
	}
	
	flux(bnd_layer.water, layer.water, [k g, day-1], "Flow from boundary") {
		bcl := -(layer.water.barocline_bnd_u + layer.water.barotropic_bnd_u)->>
		bcl    if bcl > 0,
		0      otherwise
	}

	#*/
}
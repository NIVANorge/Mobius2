

module("EasyLake", version(0, 1, 0),
	air    : compartment,
	epi    : compartment,
	hyp    : compartment,
	water  : quantity,
	ice    : quantity,
	heat   : quantity,
	temp   : property,
	precip : property,
	evap_mm : property,
	A_surf : par_real,
	epi_target : loc,
) {
"""
This is a very simple lake model for use along with cathcment models.
The physical part of the model simulates water balance and temperature.

The water balance part of the model is conceptually similar to VEMALA
[A National-Scale Nutrient Loading Model for Finnish Watersheds - VEMALA, Inse Huttunen et. al. 2016, Environ Model Assess 21, 83-109](https://doi.org/10.1007/s10666-015-9470-6)
"""

	load("stdlib/physiochemistry.txt", library("Water utils"))
	
	par_group("Lake physical", epi) {
		z_outflow : par_real("Lake depth at which outflow is 0", [m], 10, 0.1, 1642.0)
		z_epi     : par_real("Initial epilimnion thickness", [m], 2, 0.1, 10)
		dz_epi    : par_real("Epilimnion thickening rate", [m, day-1], 0.01)
		rate_l    : par_real("Rating function linear component", [m 2, s-1], 10, 0, 1000)
		t_epi     : par_real("Initial epilimnion temperature", [deg_c], 15, 0, 50)
		t_bot     : par_real("Bottom temperature", [deg_c], 4, 0, 50)
	}
	
	wedge_tip     : function(A : [m 2], z0 : [m], z : [m]) {
		0.5*A * z^2 / z0
	}
	
	wedge_section : function(A : [m 2], z0 : [m], z1 : [m], z2 : [m]) {
		wedge_tip(A, z0, z1) - wedge_tip(A, z0, z2)
	}
	
	
	#TODO should be attn in epi also, and remainder of shortwave to hyp
	
	var(epi.water, [m 3], "Epilimnion volume")  @initial {   0.5 * A_surf * z_outflow - hyp.water   }
	
	var(hyp.water, [m 3], "Hypolimnion volume") @initial {
		z := z_outflow - z_epi,
		A := A_surf * (z/z_outflow),
		0.5 * A * z
	}
	
	z_e : property("Thickness")
	depth : property("Depth")
	flow : property("Flow")
	
	var(epi.z_e, [m], "Epilimnion thickness") @initial { z_epi }
	{
		last(z_e) + (dz_epi)*time.step_length_in_seconds->> if !epi.ind & water.temp > t_bot,
		z_epi                                               otherwise
	} 
	
	#flux(epi.water, hyp.water, "Metalimnion movement") {
		#(0.5*A_surf/z_outflow)*(z_e^2-last(z_e)^2)/time.step_length_in_seconds->>
		#-0.5*A_surf*dz_epi^2/z_outflow       if !epi.indicator & water.temp > t_bot
		#(epi.water - 0.5*A_surf*z
		#wedge_section(A_surf, z_outflow, z_e+depth-z_outflow, last(z_e)+last(depth)-z_outflow)/time.step_length_in_seconds->>
	#	wedge_section(A_surf, z_outflow, z_outflow-z_e, z_outflow-last(z_e))/time.step_length_in_seconds->>
	#}
	
	flux(nowhere, epi.water, [m 3, day-1], "Precipitation to lake")           {   air.precip * A_surf ->>   }
	
	var(epi.depth, [m], "Lake depth")                {   sqrt(2*(epi.water + hyp.water)*z_outflow/A_surf)   }
	
	var(epi.water.flow, [m 3, s-1], "Lake outflow")  {   max(0, rate_l*(depth - z_outflow))   }

	lake_out :
	flux(epi.water, epi_target, [m 3, day-1], "Lake outflow flux")                   {   flow ->>  }
	
	rho_ice    : constant("Ice density", [k g, m-3], 917)
	l_freeze   : constant("Latent heat of freezing", [J, k g-1], 333500)
	lambda_ice : constant("Ice heat conduction coefficient", [W, m-1, K-1], 2.1)
	
	var(epi.water.heat, [J]) @initial {
		water_temp_to_heat(water, t_epi)
	}
	
	var(hyp.water.heat, [J]) @initial {
		# TODO: Not quite the correct formula for what the mean hypolimnion temperature should be.
		t_hyp := 0.5*(t_epi + t_bot),
		water_temp_to_heat(water, t_hyp)
	}
	
	evap :
	flux(epi.water, nowhere, [m 3, day-1], "Evaporation") {
		evap_mm*A_surf ->>
	} @no_carry { any } # Don't carry any dissolved substances
	
	flux(epi.water.heat, hyp.water.heat, [J, day-1], "Layer heat transfer") {
		V := water + hyp.water,
		lake_t := water_heat_to_temp(V, heat + hyp.water.heat), # Mean lake temperature.
		epi_t_should_be := (lake_t*V - 0.5*t_bot*hyp.water) / (water + 0.5*hyp.water),
		epi_heat_should_be := water_temp_to_heat(water, epi_t_should_be),
		5[day-1]*(heat - epi_heat_should_be)   # The 5 is pretty arbitrary. Just to get a quick equilibration
	}
	
	var(epi.water.temp, [deg_c], "Epilimnion temperature") {
		water_heat_to_temp(water, water.heat)
	} @initial { t_epi }
	
	var(hyp.water.temp, [deg_c], "Hypolimnion temperature (mean)") {
		water_heat_to_temp(water, water.heat)
	}
	
	
	# TODO: How does mixing interact with ice (?)
	ind : property("Mixing indicator")
	var(epi.ind, [], "Mixing indicator") { abs(water.temp - hyp.water.temp) < 0.4[deg_c] }
	
	# NOTE: This moves an equal body of water up and down, which does not impact the water volume, but does mix dissolved substances.
	# The no_carry for heat is because we can't let the mixing flux carry heat, since the heat transfer is computed in a different way.
	mix_down :
	flux(epi.water, hyp.water, [m 3, day-1], "Mixing down") {
		A_surf * depth * epi.ind * 1[day-1]
	} @no_carry { heat }
	
	mix_up : 
	flux(hyp.water, epi.water, [m 3, day-1], "Mixing up") {
		A_surf * epi.depth * epi.ind * 1[day-1]
	} @no_carry { heat }
}
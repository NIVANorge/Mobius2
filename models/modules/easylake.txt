

module("EasyLake", version(0, 1, 0)) {
"""
TODO: description
"""

	load("stdlib/atmospheric.txt", library("Meteorology"), library("Radiation"))
	load("stdlib/physiochemistry.txt", library("Thermodynamics"), library("Water utils"))
	load("stdlib/seawater.txt", library("Air-sea"))
	
	air  : compartment("Atmosphere")
	epi  : compartment("Epilimnion")
	hyp  : compartment("Hypolimnion")
	
	par_group("Lake physical", epi) {
		A_surf    : par_real("Lake surface area", [m 2], 107183, 0, 1e8)
		z_outflow : par_real("Lake depth at which outflow is 0", [m], 10, 0.1, 1000)
		z_epi     : par_real("Initial epilimnion thickness", [m], 2, 0.1, 10)
		dz_epi    : par_real("Epilimnion thickening rate", [m, day-1], 0.01)
		rate_l    : par_real("Rating function linear component", [m 2, s-1], 10, 0, 1000)
		t_epi     : par_real("Initial epilimnion temperature", [deg_c], 15, 0, 50)
		t_bot     : par_real("Bottom temperature", [deg_c], 4, 0, 50)
		init_ice  : par_real("Initial ice thickness", [m], 0, 0, 10)
		ice_alb   : par_real("Ice albedo", [], 0.4, 0, 1)
		th_frazil : par_real("Frazil threshold", [m], 0.05, 1e-5, 0.1)
		ice_temp  : par_real("Ice formation temperature", [deg_c], 0, -2, 2)
	}
	
	#th_frazil  : constant("Frazil threshold", [m], 0.05)
	#ice_temp   : constant("Ice formation temperature", [deg_c], 0)
	
	water  : quantity("Water")
	ice    : quantity("Ice")
	heat   : quantity("Thermal energy")
	
	temp   : property("Temperature")
	precip : property("Precipitation")
	wind   : property("Wind speed")
	g_rad  : property("Global radiation")
	
	var(air.temp,   [deg_c], "Air temperature")
	var(air.precip, [m m, day-1])
	var(air.wind,   [m, s-1])
	var(air.g_rad,  [W, m-2])
	
	lwd      : property("Downwelling longwave radiation")
	pressure : property("Pressure")
	a_hum    : property("Actual specific humidity")
	rho      : property("Density")
	
	wedge_tip     : function(A : [m 2], z0 : [m], z : [m]) {
		0.5*A * z^2 / z0
	}
	
	wedge_section : function(A : [m 2], z0 : [m], z1 : [m], z2 : [m]) {
		wedge_tip(A, z0, z1) - wedge_tip(A, z0, z2)
	}
	
	
	var(epi.water, [m 3], "Epilimnion volume")  @initial {   0.5 * A_surf * z_outflow - hyp.water   }
	
	var(hyp.water, [m 3], "Hypolimnion volume") @initial {
		z := z_outflow - z_epi,
		A := A_surf * (z/z_outflow),
		0.5 * A * z
	}
	
	z_e : property("Thickness")
	depth : property("Depth")
	flow : property("Flow")
	
	var(epi.z_e, [m], "Epilimnion thickness") @initial { z_epi }
	{
		last(z_e) + (dz_epi)*time.step_length_in_seconds->> if !epi.indicator & water.temp > t_bot,
		z_epi                                                                   otherwise
	} 
	
	#flux(epi.water, hyp.water, "Metalimnion movement") {
		#(0.5*A_surf/z_outflow)*(z_e^2-last(z_e)^2)/time.step_length_in_seconds->>
		#-0.5*A_surf*dz_epi^2/z_outflow       if !epi.indicator & water.temp > t_bot
		#(epi.water - 0.5*A_surf*z
		#wedge_section(A_surf, z_outflow, z_e+depth-z_outflow, last(z_e)+last(depth)-z_outflow)/time.step_length_in_seconds->>
	#	wedge_section(A_surf, z_outflow, z_outflow-z_e, z_outflow-last(z_e))/time.step_length_in_seconds->>
	#}
	
	flux(nowhere, epi.water, [m 3, day-1], "Precipitation to lake")           {   air.precip * A_surf ->>   }
	
	var(epi.depth, [m], "Lake depth")                {   sqrt(2*(epi.water + hyp.water)*z_outflow/A_surf)   }
	
	var(epi.water.flow, [m 3, s-1], "Lake outflow")  {   max(0, rate_l*(depth - z_outflow))   }

	lake_out :
	flux(epi.water, out, [m 3, day-1], "Lake outflow flux")                   {   flow ->>  }
	
	rho_ice    : constant("Ice density", [k g, m-3], 917)
	l_freeze   : constant("Latent heat of freezing", [J, k g-1], 333500)
	lambda_ice : constant("Ice heat conduction coefficient", [W, m-1, K-1], 2.1)
	
	var(epi.water.heat, [J]) @initial {
		water_temp_to_heat(water, t_epi)
	}
	
	var(hyp.water.heat, [J]) @initial {
		# TODO: Not quite the correct formula for what the mean hypolimnion temperature should be.
		t_hyp := 0.5*(t_epi + t_bot),
		water_temp_to_heat(water, t_hyp)
	}
	
	stab : property("Stability")
	ced : property("Transfer coefficient for latent heat flux")
	chd : property("Transfer coefficent for sensible heat flux")
	s_hum : property("Saturation specific humidity")
	lwu : property("Emitted longwave radiation")
	sw : property("Shortwave radiation")
	albedo : property("Albedo")
	
	var(epi.stab, []) {
		surface_stability(air.wind, water.temp, air.temp)
	}
	
	var(epi.ced, []) {
		tc_latent_heat(air.wind, stab)
	}
	
	var(epi.chd, []) {
		tc_sensible_heat(air.wind, stab)
	}
	
	var(epi.s_hum, []) {
		svap := saturation_vapor_pressure(water.temp),
		specific_humidity_from_pressure(air.pressure, svap)
	}
	
	var(epi.lwu, [W, m-2]) {
		emissivity := 0.98,
		emissivity * black_body_radiation(water.temp->[K])
	}
	
	var(epi.albedo, []) {
		ice_alb        if ice.indicator,
		0.045          otherwise
	}
	
	#TODO should be attn in epi also, and remainder to hyp
	var(epi.sw, [W, m-2]) {
		(1 - albedo) * (1 - ice.attn) * air.g_rad	
	}
	
	flux(nowhere, epi.water.heat, [J, day-1], "Net shortwave") {
		A_surf * sw ->>
	}
	
	flux(nowhere, epi.water.heat, [J, day-1], "Net longwave") {
		alb := 0.045,
		net_rad := (1 - alb)*air.lwd - lwu,    # W/m2
		0                              if epi.ice.indicator,
		A_surf * net_rad ->>           otherwise
	}
	
	flux(nowhere, epi.water.heat, [J, day-1], "Freeze heating") {  A_surf * ice.energy ->>  }    # Energy used to melt ice instead of heating the lake (or other way around with freezing)
	
	# TODO: Some of the surface fluxes should be modified for ice
	flux(nowhere, epi.water.heat, [J, day-1], "Latent heat flux") {
		l_vap := latent_heat_of_vaporization(temp),
		0                                                                          if epi.ice.indicator,
		A_surf * (ced * l_vap * air.rho * air.wind * (air.a_hum - s_hum)) ->>      otherwise
	}
	
	flux(nowhere, epi.water.heat, [J, day-1], "Sensible heat flux") {
		0                                                                             if epi.ice.indicator,
		A_surf * (chd * C_air * air.rho * air.wind * (air.temp->[K] - temp->[K])) ->> otherwise
	}
	
	evap_mm : property("Evaporation per area")
	
	var(epi.water.evap_mm, [m m, day-1]) {
		rho_ref := 1025 [k g, m-3],
		0                                                                          if epi.ice.indicator,
		-(air.rho / rho_ref) * chd * air.wind * (air.a_hum - s_hum) ->>            otherwise
	}
	
	evap :
	flux(epi.water, nowhere, [m 3, day-1], "Evaporation") {
		evap_mm*A_surf ->>
	} @no_carry { any } # Don't carry any dissolved substances
	
	#evap.no_carry()   #TODO: This should be allowed.
	
	flux(nowhere, epi.water.heat, [J, day-1], "Precipitation heat") {
		#precip_t := max(0.4[deg_c], air.temp),
		precip_t := air.temp,
		V := A_surf*air.precip -> [m 3, day-1],   
		water_temp_to_heat(V => [m 3], precip_t) => [J, day-1] # TODO: Not sure how to best express this. It is a bit annoying that the 1/day doesn't "pass through" the function
	}
	
	flux(epi.water.heat, hyp.water.heat, [J, day-1], "Layer heat transfer") {
		V := water + hyp.water,
		lake_t := water_heat_to_temp(V, heat + hyp.water.heat), # Mean lake temperature.
		epi_t_should_be := (lake_t*V - 0.5*t_bot*hyp.water) / (water + 0.5*hyp.water),
		epi_heat_should_be := water_temp_to_heat(water, epi_t_should_be),
		5[day-1]*(heat - epi_heat_should_be)   # The 5 is pretty arbitrary. Just to get a quick equilibration
	}
	
	var(epi.water.temp, [deg_c], "Epilimnion temperature") {
		water_heat_to_temp(water, water.heat)
	} @initial { t_epi }
	
	var(hyp.water.temp, [deg_c], "Hypolimnion temperature (mean)") {
		water_heat_to_temp(water, water.heat)
	}
	
	var(epi.ice, [m], "Ice thickness") @initial { init_ice }
	
	energy : property("Freeze energy")
	indicator : property("Indicator")
	attn : property("Attenuation coefficent")
	
	var(epi.ice.energy, [W, m-2]) {
		z_surf := 1[m],   #  Thickness of water layer that ice formation can draw energy from.
		K_ice := 200[W, m-3, deg_c-1],   # freezing/melting heat transfer coefficient ... should not affect magnitude of temperature or ice cover, only how fast they "converge"
		e := (ice_temp - epi.water.temp)*z_surf*K_ice,
		
		0        if (ice < 1e-6[m]) & (e < 0),    # No melting when there is no ice
		e        otherwise
	}
	
	var(epi.ice.indicator, [], "Ice indicator") {   ice > th_frazil   }
	
	var(epi.ice.attn, []) {
		0                       if !indicator,
		1 - exp(-5[m -1] * ice) otherwise    #TODO: the 5 should be configurable?
	}
	
	flux(nowhere, epi.ice, [m, day-1], "Ice change") {
		(energy + {
			{
				#NOTE: Stefan's law, but turned into ODE equation:
				# ice_n = sqrt(ice_{n-1}^2 + Y)  with   Y = 2*lambda_ice*(ice_temp - ice_t)
				# => d(ice^2)/dt = Y
				# and d(ice^2)/dt = 2*ice*d(ice)/dt
				# => d(ice)/dt = Y / (2*ice)
				factor := 1[m] / (10[m] + ice),
				ice_t := (factor * ice_temp + air.temp) / (1 + factor),   # Approximation of ice temperature. TODO: separate state var?
				lambda_ice * (ice_temp->[K] - ice_t->[K]) / ice
			}                                             if (air.temp <= ice_temp) & indicator,
			-(1-albedo)*air.g_rad*attn                    if indicator,  
			0                                             otherwise
		}) / (rho_ice * l_freeze) ->[m, day-1]
		+ {
			air.precip   if air.temp <= ice_temp & indicator,     # if there is ice, and temperature is below freezing, precipitation is added as ice
			0            otherwise
		}->[m, day-1]
	}
	
	
	# TODO: How does mixing interact with ice (?)
	
	var(epi.indicator, [], "Mixing indicator") { abs(water.temp - hyp.water.temp) < 0.4[deg_c] }
	
	# NOTE: This moves an equal body of water up and down, which does not impact the water volume, but does mix dissolved substances.
	# The no_carry for heat is because we can't let the mixing flux carry heat, since the heat transfer is computed in a different way.
	mix_down :
	flux(epi.water, hyp.water, [m 3, day-1], "Mixing down") {
		A_surf * depth * epi.indicator * 1[day-1]
	} @no_carry { heat }
	
	mix_up : 
	flux(hyp.water, epi.water, [m 3, day-1], "Mixing up") {
		A_surf * epi.depth * epi.indicator * 1[day-1]
	} @no_carry { heat }
}


module("EasyLake", 0, 1, 0) {
"""
TODO: description
"""

	load("../../stdlib/atmospheric.txt", library("Meteorology"))
	load("../../stdlib/physiochemistry.txt", library("Thermodynamics"), library("Water utils"))
	
	air  : compartment("Atmosphere")

	epi  : compartment("Epilimnion")
	hyp  : compartment("Hypolimnion")
	
	
	epi.par_group("Lake physical") {
		# TODO: copy the nice min-max values and comments from mobius 1 EasyLake
		A_surf    : par_real("Lake surface area", [m 2], 107183, 0, 1e8)
		z_outflow : par_real("Lake depth at which outflow is 0", [m], 10, 0.1, 1000)
		z_epi     : par_real("Initial epilimnion thickness", [m], 2, 0.1, 10)
		#th_bank   : par_real("Lake shore slope", [], 0.4, 0, 4)
		rate_l    : par_real("Rating function linear component", [m 2, s-1], 10, 0, 1000)
		t_epi     : par_real("Initial epilimnion temperature", [deg_c], 15, 0, 50)
		t_bot     : par_real("Bottom temperature", [deg_c], 4, 0, 50)
		init_ice  : par_real("Initial ice thickness", [m], 0, 0, 10)
	}
	
	water  : quantity("Water")
	ice    : quantity("Ice")
	heat   : quantity("Thermal energy")
	
	temp   : property("Temperature")
	precip : property("Precipitation")
	
	air.has(temp,      [deg_c], "Air temperature")
	air.has(precip,    [m m, day-1])
	air.has(wind     : property("Wind speed"),        [m, s-1])
	air.has(r_hum    : property("Relative humidity"), [])
	air.has(pressure : property("Pressure"),          [h Pa], "Air pressure")
	air.has(cloud    : property("Cloud cover"),       [])
	air.has(g_rad    : property("Global radiation"),  [W, m-2])
	
	
	epi.has(water, [m 3], "Epilimnion volume")  .initial {   0.5 * A_surf * z_outflow - hyp.water   }
	
	hyp.has(water, [m 3], "Hypolimnion volume") .initial {
		z := z_outflow - z_epi
		A := A_surf * (z/z_outflow)
		0.5 * A * z
	}
	
	flux(nowhere, epi.water, "Precipitation to lake")           {   air.precip * A_surf * 1e-3   }
	
	#TODO: instead let both hyp and epi have a depth and use a sum of those?
	epi.has(depth : property("Lake depth"), [m])                {   sqrt(2*(epi.water + hyp.water)*z_outflow/A_surf)   }
	
	epi.water.has(outflow : property("Flow"), [m 3, s-1], "Lake outflow") {   max(0, rate_l*(depth - z_outflow))   }

	lake_out :
	flux(epi.water, out, "Lake outflow flux")                   {   86400 * outflow   }
	
	# TODO: should have some way of turning this on/off depending on use case.
	#epi.has(inflow : property("Lake inflow"), [m 3, s-1])
	#flux(nowhere, epi.water, "Lake inflow flux")                {   86400 * inflow   }
	
	cpa        : constant("Specific heat capacity of air",    [J, k g-1, K-1], 1008)
	Rdry       : constant("Specific gas constant of dry air", [J, k g-1, K-1], 287.058)
	Rvap       : constant("Specific gas constant of vapor",   [J, k g-1, K-1], 461.495)
	rho_ice    : constant("Ice density", [k g, m-3], 917)
	l_freeze   : constant("Latent heat of freezing", [k g, m-3], 333500)
	lambda_ice : constant("Ice heat conduction coefficient", [W, m-1, K-1], 2.1)
	
	# Some of these could be parameters?
	th_frazil  : constant("Frazil threshold", [m], 0.05)
	ice_temp   : constant("Ice formation temperature", [deg_c], 0)
	
	epi.water.has(heat, [J]) .initial {
		water_temp_to_heat(water, t_epi)
	}
	
	hyp.water.has(heat, [J]) .initial {
		# TODO: initial hypolimnion temperature should be lower.
		water_temp_to_heat(water, t_epi)
	}
	
	#TODO: units for the following!
	
	epi.has(stab : property("Stability"), []) {
		ww := max(air.wind, 0.1)
		s0 := 0.25*(water.temp - air.temp) / (ww*ww)
		s0*abs(s0)/(abs(s0) + 0.01)
	}
	
	stab_modify : function(wind, stab) {
		0                                     if abs(wind) < 1e-3,
		0.1 + 0.03*stab * 0.9*exp(4.8*stab)   if stab < 0 & stab > -3.3,
		0                                     if stab < 0,
		1 + 0.63*sqrt(stab)                      otherwise
	}
	
	epi.has(ced : property("Transfer coefficient for latent heat flux"), []) {
		w    := air.wind + 1e-12
		{
			0     + 1.23  *exp(-0.16*ln(w))        if w < 2.2,
			0.969 + 0.0521*w                       if w < 5,
			1.18  + 0.01  *w                       if w < 8,
			1.196 + 0.008 *w - 0.0004*(w-8)^2      if w < 25,
			1.68  - 0.016 *w                       otherwise
		} * 1e-3 * stab_modify(air.wind, stab)
	}
	
	epi.has(chd : property("Transfer coefficent for sensible heat flux"), []) {
		w    := air.wind + 1e-12
		{
			0     + 1.185 *exp(-0.157*ln(w))       if w < 2.2,
			0.927 + 0.0546*w                       if w < 5,
			1.15  + 0.01  *w                       if w < 8,
			1.17  + 0.0075*w - 0.00045*(w-8)^2     if w < 25,
			1.652 - 0.017 *w                       otherwise
		} * 1e-3 * stab_modify(air.wind, stab)
	}
	
	# TODO: put some of this stuff into atmospheric module or library?
	
	air.has(a_vap : property("Actual vapor pressure"), [h Pa]) {
		svap := saturation_vapor_pressure_lowe(air.temp)
		air.r_hum * 0.01 * svap
	}
	
	epi.has(s_hum : property("Saturation specific humidity"), []) {
		svap := saturation_vapor_pressure_lowe(water.temp)
		specific_humidity_from_pressure(air.pressure, svap)
	}
	
	epi.has(a_hum : property("Actual specific humidity"), []) {
		specific_humidity_from_pressure(air.pressure, air.a_vap)
	}
	
	air.has(rho : property("Air density"), [k g, m-3]) {
		tk := deg_c_to_K(air.temp)
		((pressure - a_vap)/(tk*Rdry) + a_vap/(tk*Rvap)) * 100    # *100 to convert HPa -> Pa
	}
	
	#TODO: Move some radiation stuff into a radiation module
	air.has(lwd : property("Downwelling longwave radiation"), [W, m-2]) {
		air_t := deg_c_to_K(air.temp)
		dpt := dew_point_temperature(a_vap)
		dew_point_depression := dpt - air_t
		cloud_effect := 10.77 * cloud^2 + 2.34*cloud - 18.44
		vapor_effect := 0.84 * (dew_point_depression + 4.01)
		eff_t := air_t + cloud_effect + vapor_effect
		black_body_radiation(eff_t)
	}
	
	epi.has(lwu : property("Emitted longwave radiation"), [W, m-2]) {
		emissivity := 0.98
		emissivity * black_body_radiation(deg_c_to_K(water.temp))
	}
	
	#TODO should be attn in epi also, and remainder to hyp
	epi.has(sw : property("Shortwave radiation"), [W, m-2]) {
		albedo := 0.045  # TODO adjust for ice albedo (?)
		(1 - albedo) * (1 - ice.attn) * air.g_rad	
	}
	
	flux(nowhere, epi.water.heat, "Net shortwave") {
		86400 * A_surf * sw
	}
	
	flux(nowhere, epi.water.heat, "Net longwave") {
		albedo := 0.045
		net_rad := (1 - albedo)*air.lwd - lwu    # W/m2
		0                              if epi.ice.indicator,
		86400 * A_surf * net_rad       otherwise
	}
	
	flux(nowhere, epi.water.heat, "Freeze heating") {   86400 * A_surf * ice.energy   }    # Energy used to melt ice instead of heating the lake (or other way around with freezing)
	
	# TODO: Some of the surface fluxes should be modified for ice
	flux(nowhere, epi.water.heat, "Latent heat flux") {
		l_vap := latent_heat_of_vaporization(temp) * 1e6    #TODO: figure out units, and why the multiply by 1e6 ?
		0                                                                          if epi.ice.indicator,
		86400 * A_surf * (ced * l_vap * air.rho * air.wind * (a_hum - s_hum))      otherwise
	}
	
	flux(nowhere, epi.water.heat, "Sensible heat flux") {
		0                                                                          if epi.ice.indicator,
		86400 * A_surf * (chd * cpa * air.rho * air.wind * (air.temp - temp))      otherwise
	}
	
	epi.water.has(evap_mm : property("Evaporation per area"), [m m, day-1]) {
		rho_ref := 1025
		0                                                                          if epi.ice.indicator,
		(air.rho / rho_ref) * chd * air.wind * (a_hum - s_hum) * (-86400)*1000     otherwise
	}
	
	evap :
	flux(epi.water, nowhere, "Evaporation") {
		evap_mm*A_surf/1000    # convert to m^3/day
	}
	
	flux(nowhere, epi.water.heat, "Precipitation heat") {
		#precip_t := max(0.4, air.temp)
		precip_t := air.temp
		water_temp_to_heat(1e-3*A_surf*air.precip, precip_t)
		
	}
	
	flux(epi.water.heat, hyp.water.heat, "Layer heat transfer") {
		lake_heat := water.heat + hyp.water.heat
		V := water + hyp.water
		lake_t := water_heat_to_temp(V, lake_heat) # Mean lake temperature.
		epi_t_should_be := (lake_t*V - 0.5*t_bot*hyp.water) / (water + 0.5*hyp.water)
		epi_heat_should_be := water_temp_to_heat(water, epi_t_should_be)
		5*(heat - epi_heat_should_be)    # The 5 is pretty arbitrary. Just to get a quick equilibration
	}
	
	epi.water.has(temp, [deg_c], "Epilimnion temperature") {
		water_heat_to_temp(water, water.heat)
	} .initial { t_epi }
	
	hyp.water.has(temp, [deg_c], "Hypolimnion temperature (mean)") {
		water_heat_to_temp(water, water.heat)
	}
	
	epi.has(ice, [m], "Ice thickness") .initial { init_ice }
	
	epi.ice.has(energy : property("Freeze energy"), [W, m-2]) {
		z_surf := 1   #  Thickness of water layer that ice formation can draw energy from.
		K_ice := 200   # freezing/melting heat transfer coefficient ... should not affect magnitude of temperature or ice cover, only how fast they "converge"
		e := (ice_temp - epi.water.temp)*z_surf*K_ice
		
		0        if ice < 1e-6 & e < 0,    # No melting when there is no ice
		e        otherwise
	}
	
	epi.ice.has(indicator : property("Indicator"), [], "Ice indicator") {   ice > th_frazil   }
	
	epi.ice.has(attn : property("Attenuation coefficent"), []) {
		0                    if !indicator,
		1 - exp(-5 * ice)    otherwise    #TODO: the 5 should be configurable?
	}
	
	flux(nowhere, epi.ice, "Ice change") {
		(energy + {
			{
				#NOTE: Stefan's law, but turned into ODE equation:
				# ice_n = sqrt(ice_{n-1}^2 + Y)  with   Y = 2*lambda_ice*(ice_temp - ice_t)
				# => d(ice^2)/dt = Y
				# and d(ice^2)/dt = 2*ice*d(ice)/dt
				# => d(ice)/dt = Y / (2*ice)
				factor := 1 / (10 + ice)
				ice_t := (factor * ice_temp + air.temp) / (1 + factor)   # Approximation of ice temperature. TODO: separate state var?
				lambda_ice * (ice_temp - ice_t) / ice
			}                                             if air.temp <= ice_temp & indicator,
			{   #TODO: should just reuse computation for surface net shortwave ?
				albedo := 0.045
				#0 - ((1-albedo)*(air.lwd + air.g_rad*attn) - lake.lwu)
				0 - (1-albedo)*air.g_rad*attn
			}                                             if indicator,  
			0                                             otherwise
		}) * 86400 / (rho_ice * l_freeze)
		+ {
			1e-3 * air.precip   if air.temp <= ice_temp & indicator,     # if there is ice, and temperature is below freezing, precipitation is added as ice
			0                   otherwise
		}
	}
	
	
	# TODO: How does mixing interact with ice (?)
	
	epi.has(indicator, [], "Mixing indicator") { abs(water.temp - hyp.water.temp) < 0.4 }
	
	
	# NOTE: This moves an equal body of water up and down, which does not impact the wate volume, but does mix dissolved substances.
	
	mix_down :
	flux(epi.water, hyp.water, "Mixing down") {
		A_surf * depth * epi.indicator
	}
	
	mix_up : 
	flux(hyp.water, epi.water, "Mixing up") {
		A_surf * epi.depth * epi.indicator
	}
}
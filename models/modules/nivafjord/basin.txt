
module("NIVAFjord basin", version(0, 0, 2),
	air       : compartment,
	basin     : compartment,
	layer     : compartment,
	sed       : compartment,
	water     : quantity,
	salt      : quantity,
	heat      : quantity,
	temp      : property,
	salinity  : property,
	pressure  : property,
	wind      : property,
	g_rad     : property,
	rho       : property,
	attn      : property,
	z         : property,
	dz        : property,
	h         : property,
	freeze_temp : property,
	vert      : connection,
	sw_vert   : connection,
	A         : par_real,
	dz0       : par_real
) {

	load("stdlib/basic_math.txt", library("Basic"))
	load("stdlib/physiochemistry.txt", library("Water utils"), library("Basic constants"))
	load("stdlib/seawater.txt", library("Seawater"))

	var(air.temp,  [deg_c], "Air temperature")
	var(air.wind,  [m, s-1])
	var(air.g_rad, [W, m-2])

	par_group("Mixing parameters", basin) {	
		N0     : par_real("Brunt-Väisälä frequency reference", [s-1], 0.8e-2)
		Nmin   : par_real("Minimum B-V frequency", [s-1], 1e-4, 1e-10, 0.1)
		K0     : par_real("Mixing factor reference", [m 2, s-1], 0.5e-4, "Mixing factor when the B-V frequency is equal to the reference")
		alpha  : par_real("Mixing non-linear coefficient", [], 1.4)
		
		# TODO: Find correct defaults:
		Es0    : par_real("Surface additional mixing energy", [m 2, s-3], 0)
		zshalf : par_real("Halving depth of additional mixing energy", [m], 3)
		hsfact : par_real("Diminishing rate of additional mixing energy", [m], 4)
	}
	
	# TODO: There should be a sediment compartment per layer instead..
	par_group("Sediment parameters", sed) {
		T_sed  : par_real("Deep sediment temperature", [deg_c], 4)
		dz_sed : par_real("Depth of thermally active sediment layer", [m], 10)
		k_sed  : par_real("Sediment thermal conductivity", [W, m-1, K-1], 1.3)
		C_sed  : par_real("Sediment specific heat capacity", [J, k g-1, K-1], 4000)
		rho_sed : par_real("Sediment density", [k g, m-3], 2600)
		#TODO: porosity
	}
	
	par_group("Initial layer physical", layer) {
		init_t : par_real("Initial layer temperature", [deg_c], 2.5)
		init_s : par_real("Initial layer salinity", [], 20)
	}
	
	var(basin.freeze_temp, [deg_c]) { ice_formation_temperature(layer.water.salinity[vert.top])	}
	
	var(layer.dz, [m], "Layer thickness") {
		water / A
	} @initial {    dz0   }
	
	var(layer.z, [m], "Depth (to bottom of layer)") {
		z[vert.above] + dz[vert.above]
	} @no_store
	
	var(basin.h, [m], "Basin sea level") {
		aggregate(layer.dz) - aggregate(dz0)
	}
	
	var(layer.water, [m 3], "Layer water") @initial { A*dz0 }
	
	var(layer.water.salt, [k g], [k g, m-3], "Layer salt")
		@initial_conc { salinity*1e-3*rho_water }
	
	var(layer.water.heat, [J], "Layer thermal energy") 
		#TODO: C_water should at least be salinity dependent
		@initial_conc { C_water * (temp -> [K]) * rho_water }

	var(layer.water.temp, [deg_c], "Layer temperature") {
		heat / (water*C_water*rho_water) -> [deg_c]      #TODO: C_water should at least be salinity dependent
	} @initial {
		init_t
	}
	
	var(layer.water.salinity, [], "Layer salinity") {
		1e3*(conc(salt)/rho_water)
	} @initial {
		init_s
	}
	
	var(layer.water.rho, [k g, m-3], "Potential density") {
		seawater_pot_dens(temp, salinity)
	} @no_store @initial {
		#NOTE: We need to enforce the existence of this because of a bug in the framework (that will hopefully be fixed soon)
		seawater_pot_dens(temp, salinity)
	}
	
	ddens          : property("d(dens)")
	Nfreq          : property("Brunt-Väisälä frequency")
	Kt             : property("Tide wave mixing coefficient")
	Ks             : property("Additional mixing coefficient")
	Kw             : property("Wind mixing coefficient")
	wmix           : property("Water mixing")
	
	var(layer.water.pressure, [Pa]) {
		pressure[vert.above] + rho*grav*dz
	}
	
	var(layer.water.ddens, [k g, m-3]) {
		(rho[vert.below]-rho)
	} @no_store
	
	var(layer.water.Nfreq, [s-1]) {
		mdz := 0.5*(dz + dz[vert.below]),
		N2 := grav * ddens / (mdz*rho),
		sqrt(max(Nmin^2, N2))   # NOTE: ddens, hence N2, could be < 0, so we can't do max(Nmin, sqrt(N2))
	}
	
	stress         : property("Wind stress")
	emix           : property("Wind mixing energy")
	sumV           : property("Sum V above")
	potmix         : property("Potential energy needed for wind mixing")
	summix         : property("Sum used wind mixing energy")
	
	# TODO: wind stress could be moved to airsea module and maybe use GOTM version.
	# TODO: Should be stability corrected.
	var(basin.stress, [N, m-2]) {
		u := air.wind,
		c_stress := 1e-3*(0.8 + 0.9*u^8/(u^8 + 1e8[m 8, s-8])),
		air.rho*c_stress*u^2
	}
	
	#TODO: Make wind mixing instead dependent on the B-V frequency also? One issue is to determine how much energy gets "used" in each layer.
	var(basin.emix, [J], "Total wind mixing energy") {
		A[vert.top]*sqrt(stress^3/layer.water.rho[vert.top])*time.step_length_in_seconds
	}
	
	var(layer.water.sumV, [m 3]) {
		sumV[vert.above] + A[vert.above]*dz[vert.above]
	} @no_store
	
	var(layer.water.potmix, [J]) {
		max(0, grav*ddens*(sumV*A*dz/(sumV + A*dz))*((z+0.5*dz)/2))
	} @no_store
	
	var(layer.water.emix, [J]) {
		rem := max(0, basin.emix - summix),
		min(rem, potmix)
	} @no_store
	
	var(layer.water.summix, [J]) {
		emix[vert.above] + summix[vert.above]
	} @no_store
	
	var(layer.water.Kw, [m 2, s-1]) {
		
		rem := max(0, basin.emix[vert.below] - summix[vert.below]),
		mixspeed := 1[m, day-1],
		
		mixspeed*dz->>                                                    if rem > 0 & potmix < 1e-20[J],
		mixspeed*dz*safe_divide(emix[vert.below], potmix[vert.below])->>  otherwise
	}
	
	var(layer.water.Kt, [m 2, s-1]) {
		safe_divide(K0, (Nfreq/N0)^alpha)
	}
	
	var(layer.water.Ks, [m 2, s-1]) {
		eta := exp(-(z - zshalf)/hsfact),
		Es  := Es0*eta/(1+eta),
		Es / Nfreq^2
	}
	
	var(layer.water.wmix, [m, day-1]) {
		K := Kt + Ks + Kw,
		K / dz ->>
	}
	
	flux(layer.water, vert, [m 3, day-1], "Layer mixing down") { wmix*A[vert.below] } @mixing
	
	# The heat conduction is trivial compared to the mixing, so it doesn't seem necessary.
	#flux(layer.water.heat, vert, [J, day-1], "Water layer heat conduction") {
	#	mdz := 0.5*(dz + dz[below]),
	#	k_water*(temp->[K] - temp[below]->[K])*A/mdz ->>
	#}
	
	flux(layer.water.heat, sw_vert, [J, day-1], "Shortwave shine-through") {
		(in_flux(sw_vert, layer.water.heat)->[J, day-1])*(1 - attn) * A[vert.below]/A
	}
	
	#flux(layer.water.heat, sed.heat, [J, day-1], "Shortwave to sediments") {
	flux(layer.water.heat, out, [J, day-1], "Shortwave to sediments") {
		(in_flux(sw_vert, layer.water.heat)->[J, day-1])*(1 - attn) * (A - A[vert.below])/A
	}
	

	#Note: Sediment temperature seems to have minimal effect on water temperature, so if it is not needed in itself, it should be removed.
	/*
	var(sed.heat, [J], "Sediment heat") @initial {
		mass := (A - A[vert.below])*dz_sed*rho_sed,
		C_sed * mass * (T_sed->[K])
	}
	
	# Assumption of triangular shape of sediment temperature function.. Doesn't work that well, should be improved.
	var(sed.temp, [deg_c], "Sediment surface temperature") {
		mass := (A - A[vert.below])*dz_sed*rho_sed,
		1*(2*heat / (mass*C_sed) - T_sed->[K]) -> [deg_c]
	}
	
	# Water-Sediment heat transfer
	flux(layer.water.heat, sed.heat, [J, day-1], "Water-sediment heat transfer") {
		dz := dz_sed*0.2,  # Just the scaling factor for the transfer TODO: get a better estimate
		(A - A[vert.below])*(temp->[K] - sed.temp->[K])*k_sed/dz ->>
	}
	*/
}
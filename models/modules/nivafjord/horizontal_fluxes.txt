
module("NIVAFjord horizontal fluxes", version(0, 0, 1),
	air    : compartment,
	basin  : compartment,
	bnd_basin : compartment,
	layer  : compartment,
	bnd_layer : compartment,
	river  : compartment,
	edge   : compartment,
	edge_layer : compartment,
	water  : quantity,
	salt   : quantity,
	temp   : property,
	salin  : property,
	flow   : property,
	rho    : property,
	pressure : property,
	dz     : property,
	h      : property,
	precip : property,
	evap   : property,
	
	horz   : connection,
	vert   : connection,
	w_bnd  : par_real,
	A      : par_real
) {

	load("stdlib/seawater.txt", library("Seawater"))
	load("stdlib/physiochemistry.txt", library("Water utils"))
	
	# Should we index this one over basin or connection?
	par_group("Horizontal exchange") {
		alpha_u : par_real("Pressure difference flow coefficient", [], 0.5, 0.1, 1)
	}

	vert_target : property("Vertical exchange target")
	
	var(river.vert_target, [], "Outlet vertical target")
	
	external_computation("Place river horizontal fluxes", "nivafjord_place_river_flux", river) {
		result(river.vert_target)
		river.water.rho
		river.water.rho[horz.below]
	} @allow_connection(river, horz)
	
	flux(river.water, layer.water[horz.below, vert.specific], [m 3, s-1], "River discharge to fjord") {
		flow->>
	} @specific { river.vert_target }
	

	# TODO: Could have a SimplyCl module
	var(river.water.salin, [], "River salinity") {  0  } @no_store
	
	var(river.water.salt, [k g], [k g, m-3]) @override_conc {   1e-3*salin*rho_water   }
	
	var(river.water.rho, [k g, m-3]) {
		seawater_pot_dens(temp, salin)
	}
	
	var(edge_layer.vert_target, [], "Fjord layer horizontal exchange vertical target")
	
	external_computation("Place horizontal fluxes", "nivafjord_place_horizontal_fluxes", edge) {
		result(edge_layer.vert_target)
		layer.water.rho
		layer.water.rho[horz.below]
		layer.water.pressure
		layer.water.pressure[horz.below]
		w_bnd
	} @allow_connection(layer, horz)
	
	dP : property("Pressure difference")
	
	
	var(edge_layer.dP, [Pa])
	{
		layer.water.pressure - layer.water.pressure[horz.below]
	}
	
	# Note: The only reason we don't just pass the h-value directly to the external comp is that we can't get h[horz.below] since basin is not on the connection.
	#    This is annoying and should be possible to do somehow.
	# Maybe need sub-compartments, and then only put the parent compartment on the connection, which would also be good for EasyReservoir.
	/*
	align_z : property("Aligned depth")
	
	var(layer.align_z, [m], "Aligned depth of layer bottom") {
		dz - basin.h                        if is_at[vert.top],
		layer.align_z[vert.above] + dz      otherwise
	} @no_store
	
	var(bnd_layer.align_z, [m], "Aligned depth of boundary layer bottom") {
		dz - bnd_basin.h                    if is_at[vert.top],
		bnd_layer.align_z[vert.above] + dz  otherwise
	} @no_store
	
	external_computation("Compute pressure difference", "nivafjord_compute_pressure_difference", edge) {
		result(edge_layer.dP)
		layer.align_z
		layer.align_z[horz.below]
		layer.dz
		layer.dz[horz.below]
		layer.water.pressure
		layer.water.pressure[horz.below]
	} @allow_connection(layer, horz)
	*/
	
	horz_flow_vel : property("Horizontal flow velocity")
	var(edge_layer.horz_flow_vel, [m, s-1], "Layer horizontal flow velocity") {
		copysign(sqrt(2*alpha_u*abs(dP)/rho_water), dP)->>
	}
	
	horz_flow : property("Horizontal flow")
	var(edge_layer.horz_flow, [m 3, day-1], "Layer horizontal outflow") {
		#NOTE: This can be both positive and negative depending on the flow direction.
		#copysign(sqrt(2*alpha_u*abs(dP)/rho_water), dP) * w_bnd * layer.dz ->>
		horz_flow_vel*w_bnd*layer.dz->>
	}
	
	flux(layer.water, layer.water[horz.below, vert.specific], [m 3, day-1], "Layer horizontal outflow flux") {
		edge_layer.horz_flow
	} @specific {
		edge_layer.vert_target
	} @bidirectional
	
	horz_bal : property("Horizontal water balance")
	var(layer.water.horz_bal, [m 3, day-1]) {
		#TODO: If we implement out_flux, we don't need the separate horz_flow variable.
		aggregate(edge_layer.horz_flow) - in_flux(horz, water)->>
	}
	
	align : property("Vertical realignment")
	var(layer.water.align, [m 3, day-1])
	
	# NOTE: Needs to be external computation since it would otherwise require reverse iteration (could be implemented later maybe)
	
	external_computation("Layer vertical realignment computation", "nivafjord_vertical_realignment", basin) {
		result(layer.water.align)
		layer.water.horz_bal
	}
	
	/*
	surf_bal : property("Surface water balance") # Could also be computed in airsea..
	var(basin.surf_bal, [m 3, day-1]) {   (evap - air.precip)*A[vert.top] ->>   }
	
	external_computation("Layer vertical realignment computation", "nivafjord_vertical_realignment_even_distrib", basin) {
		result(layer.water.align)
		layer.water.horz_bal
		A
		basin.surf_bal
	}
	*/
	
	flux(layer.water, vert, [m 3, day-1], "Vertical realignment flux") {
		align
	} @bidirectional
	
	#align_frac : property("Alignment fraction")    #TODO: Why does this break the program?? Seems to affect the value of water, but it shouldn't be able to.
	#var(layer.align_frac, [day-1]) {
	#	water.align/water
	#}
}

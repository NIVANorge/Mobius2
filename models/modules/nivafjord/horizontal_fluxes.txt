


module("NIVAFjord horizontal fluxes", version(0, 0, 1),
	layer  : compartment,
	river  : compartment,
	outlet : compartment,
	edge   : compartment,
	edge_layer : compartment,
	water  : quantity,
	heat   : quantity,
	salt   : quantity,
	salin  : property,
	flow   : property,
	rho    : property,
	temp   : property,
	horz   : connection,
	vert   : connection,
	w_bnd  : par_real
) {

	load("stdlib/seawater.txt", library("Seawater"))

	vert_target : property("Fjord vertical exchange target")
	
	var(river.vert_target, [], "River vertical target")
	
	special_computation("Place horizontal fluxes", "nivafjord_place_river_flux", outlet) {
		result(river.vert_target)
		river.water.rho
		layer.water.rho[horz.below]
	}
	
	flux(river.water, layer.water[horz.below, vert.specific], [m 3, day-1], "River discharge to fjord") {
		flow->>
	} @specific { vert_target }
	
	#TODO: Only until we figure out how to do this properly
	flux(out, layer.water.heat, [J, day-1], "Horizontal flux heat equivalent removal") {
		-in_flux(horz, layer.water)*conc(heat)
	}
	flux(out, layer.water.salt, [k g, day-1], "Horizontal flux salt equivalent removal") {
		-in_flux(horz, layer.water)*conc(salt)->>
	}
	
	# TODO: Could have a SimplyCl module
	var(river.water.salt, [k g]) @override_conc { 0=>> }
	
	var(river.water.salin, []) {
		rho_water := 1000[k g, m-3],
		(conc(salt)/rho_water)*1000
	}
	
	var(river.water.rho, [k g, m-3]) {
		seawater_pot_dens(temp, salin)
	}
	
	/*
	var(edge_layer.vert_target, [], "Fjord layer boundary horizontal exchange vertical target")
	
	
	# How would the framework know that this one is only for the edge layers, not below that (?)
	# Or maybe it doesn't need to, and it just does a 'break' when w_bnd becomes 0.
	# That is simpler, but wastes some time series storage space.
	special_computation("Place horizontal boundary fluxes", "nivafjord_place_horizontal_fluxes", edge) {
		result(edge_layer.vert_target)
		layer.water.rho
		layer.water.rho[horz.below]
		w_bnd
	}
	*/
}



/*
	#TODO: This is now just sketching, it has to be reworked.

	#w_bnd_ : property("Width to boundary")
	A_bnd : property("Total area to boundary")
	tot_barotropic_u : property("Total barotropic boundary flux")
	barotropic_bnd_u : property("Barotropic boundary flux")
	horz_target : property("Target of horizontal flux")
	
	var(oair.A_bnd, [m 2]) { aggregate(layer.w_bnd_)*dz }
	
	var(oair.h, [m]) @override { bnd.h }
	
	var(oair.tot_barotropic_u, [m 3, s-1]) {
		-(h - last(h))*A[vert.top]/time.step_length_in_seconds
	}
	
	var(layer.water.barotropic_bnd_u, [k g, s-1]) {
		#0[m 3, s-1] #TODO.
		oair.tot_barotropic_u * w_bnd * dz * rho_water / oair.A_bnd
	}
	
	flux(bnd_layer.water, layer.water[vert2.specific], [k g, day-1], "Horizontal flow") {
		bcl := -(layer.water.barocline_bnd_u + layer.water.barotropic_bnd_u)->>,
		bcl    if bcl > 0,
		0      otherwise
	} @specific {
		layer.water.horz_target
	}

*/

module("Atmospheric", 0, 1, 0) {
	"""
	Simple module for some common atmospheric attributes
	"""
	
	load("stdlib/atmospheric.txt", library("Meteorology"), library("Radiation"))
	load("stdlib/basic_math.txt", library("Basic"))
	
	air : compartment("Atmosphere")
	
	air.par_group("Location") {
		 #TODO: maybe reused across modules...
		latitude : par_real("Latitude", [deg], 60, -90, 90)
		elev     : par_real("Elevation", [m], 0, 0, 8887)
	}
	
	temp     : property("Temperature")
	r_hum    : property("Relative humidity")
	wind     : property("Wind speed")
	
	g_rad_cloud_free : property("Solar radiation on a clear sky day")
	g_rad            : property("Global radiation")
	cloud            : property("Cloud cover")
	pressure         : property("Pressure")
	s_vap            : property("Saturation vapour pressure")
	a_vap            : property("Actual vapour pressure")
	a_hum            : property("Actual specific humidity")
	dens             : property("Density")
	lwd              : property("Downwelling longwave radiation")
	
	var(air.temp,  [deg_c], "Air temperature")
	var(air.r_hum, [perc])
	var(air.wind,  [m, s-1])
	
	# The idea is that some of these can be overridden with input data if it exists. TODO: make a .can_override or something like that to allow it.
	
	var(air.g_rad_cloud_free, [W, m-2]) {
		ext := daily_average_extraterrestrial_radiation(latitude, time.day_of_year, time.days_this_year=>[day])
		clear_sky_shortwave(ext, elev)
	}
	
	#TODO: Should maybe parametrize the cloud cover - radiation thing
	var(air.g_rad,  [W, m-2]) {
		(1 - 0.75*cloud^3.4) * g_rad_cloud_free
	}
	
	var(air.cloud,  []) {
		ext := daily_average_extraterrestrial_radiation(latitude, time.day_of_year, time.days_this_year=>[day])
		g_rad_cloud_free := clear_sky_shortwave(ext, elev)
		#cc := ((1 - g_rad/g_rad_cloud_free)/0.75)^(1/3.4)     #Hmm, this just didn't work that well. Find something better?
		#cc := (1 - (1.1*g_rad/g_rad_cloud_free - 0.6))
		cc := 1 - g_rad/g_rad_cloud_free                 # Works much better for EasyLake on VansjÃ¸... May be other complicating factors though.
		clamp(cc, 0, 1)
	}
	
	var(air.pressure, [h Pa], "Air pressure") {
		mean_barometric_pressure(elev)
	}
	
	var(air.s_vap, [h Pa]) {
		saturation_vapor_pressure(temp)
	}
	
	var(air.a_vap, [h Pa]) {
		(r_hum->[]) * s_vap
	}
	
	var(air.a_hum, []) {
		specific_humidity_from_pressure(air.pressure, air.a_vap)
	}
	
	var(air.dens, [k g, m-3], "Air density") {
		air_density(temp, pressure, a_vap)
	}
	
	var(air.lwd, [W, m-2]) {
		downwelling_longwave(air.temp, a_vap, cloud)
	}
}
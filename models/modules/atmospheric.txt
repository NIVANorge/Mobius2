
module("Atmospheric", version(0, 1, 0),
	air      : compartment,
	temp     : property,
	wind     : property,
	g_rad    : property,
	pressure : property,
	a_hum    : property,
	dens     : property,
	lwd      : property
) {
"""
Simple module for some common atmospheric attributes.
The user must provide either "Global radiation" or "Cloud cover" as an input series, but one of these can be computed from the other.
"""
	
	load("stdlib/atmospheric.txt", library("Meteorology"), library("Radiation"))
	load("stdlib/basic_math.txt", library("Basic"))

	par_group("Location", air) {
		 #TODO: Elevation could be used in other modules, and should maybe be declared in model scope.
		latitude : par_real("Latitude", [deg], 60, -90, 90, "Only used if Global radiation is not provided as a series")
		elev     : par_real("Elevation", [m], 0, 0, 8887,   "Only used if Global radiation is not provided as a series")
	}
	
	r_hum            : property("Relative humidity")
	g_rad_cloud_free : property("Solar radiation on a clear sky day")
	cloud            : property("Cloud cover")
	#TODO: These two should instead be declared in model scope, for potential use with PET model.
	s_vap            : property("Saturation vapour pressure")
	a_vap            : property("Actual vapour pressure")
	
	var(air.temp,  [deg_c], "Air temperature")
	var(air.r_hum, [perc])
	var(air.wind,  [m, s-1])
	
	# The idea is that some of these can be overridden with input data if it exists. TODO: make a @can_override or something like that to allow it.
	
	var(air.g_rad_cloud_free, [W, m-2]) {
		ext := daily_average_extraterrestrial_radiation(latitude, time.day_of_year, time.days_this_year=>[day]),
		clear_sky_shortwave(ext, elev)
	}
	
	#TODO: Should maybe parametrize the cloud cover - radiation relationship
	var(air.g_rad,  [W, m-2]) {
		(1 - 0.75*cloud^3.4) * g_rad_cloud_free
	}
	
	var(air.cloud,  []) {
		#cc := ((1 - g_rad/g_rad_cloud_free)/0.75)^(1/3.4),     #Hmm, this just didn't work that well. Find something better?
		#cc := (1 - (1.1*g_rad/g_rad_cloud_free - 0.6)),
		cc := 1 - g_rad/g_rad_cloud_free,                 # Works much better for EasyLake on VansjÃ¸... May be other complicating factors though.
		clamp(cc, 0, 1)
	}
	
	var(air.pressure, [h Pa], "Air pressure") {
		mean_barometric_pressure(elev) ->>
	}
	
	var(air.s_vap, [h Pa]) {
		saturation_vapor_pressure(temp)
	}
	
	var(air.a_vap, [h Pa]) {
		(r_hum->[]) * s_vap
	}
	
	var(air.a_hum, []) {
		specific_humidity_from_pressure(pressure, a_vap)
	}
	
	var(air.dens, [k g, m-3], "Air density") {
		air_density(temp, pressure, a_vap)
	}
	
	var(air.lwd, [W, m-2]) {
		downwelling_longwave(temp, a_vap, cloud)
	}
}
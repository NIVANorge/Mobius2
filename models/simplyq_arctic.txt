

model("SimplyArctic") {

	air    : compartment("Atmosphere")
	soil   : compartment("Soil")
	deepgw : compartment("Deep groundwater")
	snow_box : compartment("Snow box")
	glacier  : compartment("Glacier")
	river    : compartment("River")
	
	water : quantity("Water")
	snow  : quantity("Snow (water equivalents)")
	ice   : quantity("Ice (water equivalents)")
	
	temp   : property("Temperature")
	precip : property("Precipitation")
	flow   : property("Flow")
	pet    : property("Potential evapotranspiration")
	ddf    : property("Degree-day factor")
	
	downhill   : connection("Downhill", directed_tree)   { soil+ river }
	downstream : connection("Downstream", directed_tree) { river+ out }
	
	load("modules/pet.txt",       module("Degree-day PET", air, soil, pet, temp))
	
	load("modules/simplyq.txt",	module("SimplyQ river", river, water, flow, loc(downstream)))
	
	
	sc     : index_set("Subcatchment")
	patch  : index_set("Patch")
	aspect : index_set("Aspect")
	
	
	distribute(snow_box, sc, patch, aspect)
	distribute(glacier,  sc, patch)  # Maybe also aspect? Then would need to change aggregation_weight
	distribute(soil,     sc, patch)
	distribute(deepgw,   sc)
	distribute(river,    sc)
	distribute(air,      sc, patch)

	par_group("Catchment data", river) {
		a_catch    : par_real("Catchment area", [k m 2], 51.7, 1e-6, 7e6)
        elev_catch : par_real("Elevation of input met data", [m], 100, -420, 8848)
	}
	
	par_group("Patch data", soil) {
		rel_area : par_real("Relative area", [], 0.2, 0, 1)
	}
	
	par_group("Aspect data", snow_box) {
		rel_aspect : par_real("Aspect relative area", [], 0.2, 0, 1)
	}
    
    par_group("Global melt parameters") {
		t_melt    : par_real("Melt temperature", [deg_c], 0, -4, 4, "Temperature at which snow and glacier ice start melting")
    }
	
	unit_conversion(glacier.water, river.water) { a_catch }
	unit_conversion(soil.water, river.water)  { a_catch }
	unit_conversion(deepgw.water, river.water) { a_catch }
	
	aggregation_weight(snow_box, glacier) { rel_aspect }
	aggregation_weight(soil, soil)     { rel_area / rel_area[below] }
	aggregation_weight(glacier, river) { rel_area }
	aggregation_weight(soil, river)    { rel_area }
	aggregation_weight(soil, deepgw)   { rel_area }  # Because in this setup the groundwater is the entire subcatchment.
	
	simply_solver : solver("Simply solver", "INCADascru", 0.1, 1e-3)
	
	solve(simply_solver, soil.water, deepgw.water, river.water, glacier.water)
	
    #-----------------------------------------------------
	module("ArcticAtmosphere", version(0, 0, 1)) {
		
		par_group("Elevation data", soil) {
			elev : par_real("Average elevation", [m], 0, 0, 8887)
		}
		
		par_group("Temperature correction") {
			lapse_rate : par_real("Temp lapse rate", [deg_c, m-1], -0.006, -0.1, 0, "Rate of change in air temperature as elevation increases")
		}
		
		mtemp : property("Air temperature")
		var(air.mtemp, [deg_c]) # Input series
		
        # Elevation correction of input air temperature
        # N.B.1 THIS ASSUMES ELEVATION OF INPUT MET DATA = MEAN ELEVATION OF WHOLE CATCH. Come back to
        # N.B.2 Could change air temp with aspect too, but decide to just implement that through changing
        # the DDF by aspect for now
		var(air.temp, [deg_c], "Local air temperature") {
			mtemp + (elev-elev_catch)*lapse_rate
		}
		
        # TO DO: may want to do a precipitation correction for elevation too. See Killingtveit.
		var(air.precip, [m m, day-1]) # Input series
	}
	
	
	
	temp2 : quantity("Surface temperature")
	
	solve(simply_solver, soil.temp2)
    
    #-----------------------------------------------------
	
	module("SimplyPermafrost", version(0, 0, 1)) {
	
		ice_epsilon : constant("Ice epsilon", [m m], 1e-6)
	
		runoff_target : loc(downhill)
	
		load("stdlib/basic_math.txt", library("Response"), library("Basic"))
	
		par_group("Hydrology general") {
			bfi    : par_real("Baseflow index", [],                        0.6,  0,    1)
			qqinfl : par_real("Quick flow inflection point", [m m, day-1], 160, 20,  2000)
		}
		
		par_group("Hydrology land", soil) {
			fc     : par_real("Field capacity", [m m],                     120,  0, 1000)
			tc_s   : par_real("Soil water time constant", [day],             2,  1,   40)
		}
			
		par_group("Groundwater", deepgw) {
			tc_g    : par_real("Groundwater time constant", [day],          30,  1,  400)
		}
		
		par_group("Soil temperature") {
			T_b      : par_real("Deep soil temperature", [deg_c], -4)
			b        : par_real("Thawing depth coefficient", [m m], 2000)
			hc_by_hc : par_real("Soil heat conduction divided by heat capacity", [day-1], 1e-3)
		}
		
		th : property("Thawing depth")
		
		var(soil.temp2, [deg_c], "Soil surface temperature") @initial { 0[deg_c] } #TODO
		
		
		flux(soil.temp2, out, [deg_c, day-1], "Surface temperature change") {
			above_t := air.temp,  #TODO Modify if snow or ice and make snow temp not air temp
			(soil.temp2 - above_t)*hc_by_hc->>
		}
		
		var(soil.th, [m m], "Soil thaw depth") {
			max(0, b * ln((T_b - temp2)/T_b))
		}
		
		var(soil.water, [m m], "Soil water volume")  @initial { th }
		var(deepgw.water,   [m m], "Groundwater volume") @initial {
			tc_g * river.water.flow / a_catch -> [m m]
			#0[m m]     #TODO: make it actually "see" a_catch
		}
		
		
		#TODO: Turn off when snow or ice cover.
		flux(soil.water, out, [m m, day-1], "Evapotranspiration") {
			0                                     if (aggregate(snow_box.snow) > ice_epsilon) | (glacier.ice > ice_epsilon),
			s_response(water, 0.5*fc, fc, 0, pet) otherwise
		} @no_carry  # Don't carry dissolved substances in the evapotranspiration
		
		flux(soil.water, runoff_target, [m m, day-1], "Quick flow") {
			drylim := 0.9,		# Could be a parameter. Stops quick flow below drylim*fc
			flow   := in_flux(water) + in_flux(downhill, water),
			flow * s_response(water, drylim*fc, fc, 0, 1) * atan(flow/qqinfl)*2/pi
		}
		
		var(soil.water.flow, [m m, day -1], "Soil water flow") {
			rate := (water - fc)/tc_s,
			s_response(water, fc, 1.01*fc, 0, rate) # smoothly turn the flow rate on between water volumes of fc and 1.01*fc
		}
		
		flux(soil.water, runoff_target, [m m, day-1], "Soil runoff")            {   flow * (1 - bfi)   }
		
		flux(soil.water, deepgw.water, [m m, day-1], "Recharge")                    {   flow * bfi   }
		
		flux(deepgw.water, river.water, [m m, day-1], "Groundwater runoff")           {   water / tc_g   }
	}
	
	
    #-----------------------------------------------------
	#TODO Ice & snow sublimation?
	
	module("ArcticSnow", version(0, 0, 1)) {
	
		water_target : loc(glacier.water)
	
		par_group("Snow") {
			ddf0_melt : par_real("Degree-day factor for snowmelt", [m m, deg_c-1, day-1], 2.74, 0, 5, "Linear correlation between rate of snow melt and air temperature")
			t_snow    : par_real("Temperature at which precip falls as snow", [deg_c], 0, -4, 4)
			refr_eff  : par_real("Refreeze efficiency", [], 0.5, 0, 1, "Speed of refreeze of liquid water in snow relative to speed of melt at the opposite temperature differential")
			snow_liq  : par_real("Liquid water fraction", [], 0.1, 0, 1, "How many mm liquid water one mm of snow (water equivalents) can hold before the water is released")
			init_snow : par_real("Initial snow depth (water equivalents)", [m m], 0, 0, 50000)
			
			fall_factor : par_real("Snow fall correction factor", [], 1, 0, 1)
		}
		
		par_group("Snow aspect", snow_box) {
			aspect_melt_factor : par_real("Aspect melt factor", [], 1, 0.1, 1)
		}
	
		var(snow_box.snow.temp, [deg_c], "Snow temperature") {
			last(temp) + (air.temp - last(temp))*0.4   #TODO!
		}
		
		var(snow_box.ddf, [m m, deg_c-1, day-1], "Snow melt degree-day factor") {
			aspect_melt_factor * ddf0_melt #TODO maybe also radiation something
		}
		
		var(snow_box.snow,  [m m], "Snow depth") @initial { init_snow }
		var(snow_box.water, [m m], "Snow water")
		
		flux(out, snow_box.snow, [m m, day-1], "Precipitation falling as snow") { fall_factor * air.precip * (air.temp <= t_snow)  } # Making use of auto-cast of boolean->real
		
        # this could  be to water_target if refreeze and liquid water fraction removed
		flux(out, snow_box.water, [m m, day-1], "Precipitation falling as rain")  {  air.precip * (air.temp > t_snow)  }
		
        # Need to use snow.temp here rather than air.temp? What do people normally do?
		melt :
		flux(snow_box.snow, snow_box.water, [m m, day-1], "Melt")       {   max(0, ddf*(snow.temp - t_melt))   }
		
        # Need this? Delete if not
		refreeze :
		flux(snow_box.water, snow_box.snow, [m m, day-1], "Refreeze")   {   max(0, refr_eff*ddf*(t_melt - snow.temp))  }
        
        # Need snow_liq? If not, redo this
		melt_runoff :
		flux(snow_box.water, water_target, [m m, day-1], "Melt runoff") {   max(0, water - snow*snow_liq)*1[day-1]  }
        
        #TODO: Sublimation? ET from snow?

		discrete_order {
			melt
			refreeze
			melt_runoff
		}
	}
	
    #-----------------------------------------------------
	module("SimplyGlacier", version(0, 0, 1)) {
		
		ice_epsilon : constant("Ice epsilon", [m m], 1e-6)
		
		par_group("Glacier global") {
			K_min   : par_real("Glacier runoff coefficient min", [day-1], 1)
			K_range : par_real("Glacier runoff coefficient range", [day-1], 0)
			A_G     : par_real("Glacier runoff snow dependence", [m m-1], 0)
			perc_frac : par_real("Percolation fraction", [], 0.1, 0, 1, "Proportion of glacier water flow that percolates down to the underlying ground vs going directly to the reach")
			ddf_ice : par_real("Relative degree-day ice melt", [m m, deg_c-1, day-1], 1)
			snowtoice : par_real("Glacier accumulation coefficient", [day-1], 0, 2.7e-4, 1e-3)
		}
		
		par_group("Glacier", glacier) {
			init_ice : par_real("Initial ice thickness", [m m], 0)
		}
		
		var(glacier.ice, [m m], "Glacier ice") @initial { init_ice }
		
		var(glacier.water, [m m], "Glacier melt water")
		
        # TODO. Maybe just delete and use air temp
		var(glacier.ice.temp, [deg_c], "Ice temperature") {
			air.temp  # TODO
		}
		
		flux(snow_box.snow, glacier.ice, [m m, day-1], "Glacier accumulation") {
			snowtoice * snow if last(glacier.ice) > ice_epsilon,
			0                otherwise
		}
		
		flux(glacier.ice, glacier.water, [m m, day-1], "Glacier melt") {
            # no melt if there is snow on the box					
			0                     if aggregate(snow_box.snow) > ice_epsilon,
			max(0, ddf_ice*(ice.temp - t_melt))  otherwise
		}
		
		#TODO: glacier melt depends on aspect too
		
		var(glacier.water.flow, [m m, day-1], "Glacier water flow") {
			water * (K_min + K_range * exp(-A_G * aggregate(snow_box.snow)))
		}
		
		flux(glacier.water, river.water, [m m, day-1], "Glacier runoff") {
			(1-perc_frac)*flow if ice > ice_epsilon,
			0                  otherwise
		}
		
        # Flux of glacier water down to underlying soil water vs going straight to the channel
        # Water passes straight through the glacier box when no ice is present
		flux(glacier.water, soil.water, [m m, day-1], "Glacier percolation") {
			perc_frac*flow                            if ice > ice_epsilon,
			in_flux(water)                            otherwise
		}
	}
	
	
}
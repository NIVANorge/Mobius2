

model("SimplyArctic") {

	air    : compartment("Atmosphere")
	soil   : compartment("Soil")
	deepgw : compartment("Deep groundwater")
	snow_box : compartment("Snow box")
	glacier  : compartment("Glacier")
	river    : compartment("River")
	
	water : quantity("Water")
	snow  : quantity("Snow (water equivalents)")
	ice   : quantity("Ice (water equivalents)")
	
	temp   : property("Temperature")
	precip : property("Precipitation")
	flow   : property("Flow")
	pet    : property("Potential evapotranspiration")
	ddf    : property("Degree-day factor")
	
	downhill   : connection("Downhill", directed_tree)   { (soil|river)* }
	downstream : connection("Downstream", directed_tree) { river* }
	
	load("modules/pet.txt",       module("Degree-day PET", air, soil, pet, temp))
	
	#TODO: Air temperature should be variable based on elevation zone, and just have a single input series that is adjusted.
	
	load("modules/simplyq.txt",	module("SimplyQ river", river, water, flow, loc(downstream)))
	
	
	sc     : index_set("Subcatchment")
	patch  : index_set("Patch")
	facing : index_set("Facing")
	
	
	distribute(snow_box, sc, patch, facing)
	distribute(glacier,  sc, patch)
	distribute(soil,     sc, patch)
	distribute(deepgw,   sc)
	distribute(river,    sc)
	distribute(air,      sc, patch)
	

	par_group("Catchment data", river) {
		a_catch  : par_real("Catchment area", [k m 2], 51.7, 1e-6, 7e6)
	}
	
	par_group("Patch data", soil) {
		rel_area : par_real("Relative area", [], 0.2, 0, 1)
	}
	
	par_group("Facing data", snow_box) {
		rel_facing : par_real("Facing relative area", [], 0.2, 0, 1)
	}
	
	unit_conversion(glacier.water, river.water) { a_catch }
	unit_conversion(soil.water, river.water)  { a_catch }
	unit_conversion(deepgw.water, river.water) { a_catch }
	
	aggregation_weight(snow_box, glacier) { rel_facing }
	aggregation_weight(soil, soil)     { rel_area / rel_area[below] }
	aggregation_weight(glacier, river) { rel_area }
	aggregation_weight(soil, river)    { rel_area }
	aggregation_weight(soil, deepgw)   { rel_area }  # Because in this setup the groundwater is the entire subcatchment.
	
	simply_solver : solver("Simply solver", "INCADascru", 0.1, 1e-3)   # NOTE: The small relative minimal step is needed by SimplyTox.
	
	solve(simply_solver, soil.water, deepgw.water, river.water, glacier.water)
	
	module("ArcticAtmosphere", version(0, 0, 1)) {
		
		par_group("Elevation data", soil) {
			elev : par_real("Elevation", [m], 0, 0, 8887)
		}
		
		par_group("Temperature correction") {
			temp_elev : par_real("Temperature elevation correction", [deg_c, m-1], -0.01, -0.1, 0)
		}
		
		mtemp : property("Air temperature")
		var(air.mtemp, [deg_c]) # This is the input series.
		
		var(air.temp, [deg_c], "Local air temperature") {
			mtemp + elev*temp_elev
		}
		
		var(air.precip, [m m, day-1]) # Input series
	}
	
	
	
	temp2 : quantity("Surface temperature")
	
	solve(simply_solver, soil.temp2)
	
	module("SimplyPermafrost", version(0, 0, 1)) {
	
		ice_epsilon : constant("Ice epsilon", [m m], 1e-6)
	
		runoff_target : loc(downhill)
	
		load("stdlib/basic_math.txt", library("Response"), library("Basic"))
	
		par_group("Hydrology general") {
			bfi    : par_real("Baseflow index", [],                        0.6,  0,    1)
			qqinfl : par_real("Quick flow inflection point", [m m, day-1], 160, 20,  2000)
		}
		
		par_group("Hydrology land", soil) {
			fc     : par_real("Field capacity", [m m],                     120,  0, 1000)
			tc_s   : par_real("Soil water time constant", [day],             2,  1,   40)
		}
			
		par_group("Groundwater", deepgw) {
			tc_g    : par_real("Groundwater time constant", [day],          30,  1,  400)
		}
		
		par_group("Soil temperature") {
			T_b      : par_real("Deep soil temperature", [deg_c], -4)
			b        : par_real("Thawing depth coefficient", [m m], 2000)
			hc_by_hc : par_real("Soil heat conduction divided by heat capacity", [day-1], 1e-3)
		}
		
		th : property("Thawing depth")
		
		var(soil.temp2, [deg_c], "Soil surface temperature") @initial { 0[deg_c] } #TODO
		
		
		flux(soil.temp2, nowhere, [deg_c, day-1], "Surface temperature change") {
			above_t := air.temp,  #TODO Modify if snow or ice and make snow temp not air temp
			(soil.temp2 - above_t)*hc_by_hc->>
		}
		
		var(soil.th, [m m], "Soil thaw depth") {
			max(0, b * ln((T_b - temp2)/T_b))
		}
		
		var(soil.water, [m m], "Soil water volume")  @initial { th }
		var(deepgw.water,   [m m], "Groundwater volume") @initial {
			tc_g * river.water.flow / a_catch -> [m m]
			#0[m m]     #TODO: make it actually "see" a_catch
		}
		
		
		#TODO: Turn off when snow or ice cover.
		flux(soil.water, nowhere, [m m, day-1], "Evapotranspiration") {
			0                                     if (aggregate(snow_box.snow) > ice_epsilon) | (glacier.ice > ice_epsilon),
			s_response(water, 0.5*fc, fc, 0, pet) otherwise
		} @no_carry   # Don't carry dissolved substances in the evapotranspiration
		
		flux(soil.water, runoff_target, [m m, day-1], "Quick flow") {
			drylim := 0.9,		# Could be a parameter. Stops quick flow below drylim*fc
			flow   := in_flux(water) + in_flux(downhill, water),
			flow * s_response(water, drylim*fc, fc, 0, 1) * atan(flow/qqinfl)*2/pi
		}
		
		var(soil.water.flow, [m m, day -1], "Soil water flow") {
			rate := (water - fc)/tc_s,
			s_response(water, fc, 1.01*fc, 0, rate) # smoothly turn the flow rate on between water volumes of fc and 1.01*fc
		}
		
		flux(soil.water, runoff_target, [m m, day-1], "Soil runoff")            {   flow * (1 - bfi)   }
		
		flux(soil.water, deepgw.water, [m m, day-1], "Recharge")                    {   flow * bfi   }
		
		flux(deepgw.water, river.water, [m m, day-1], "Groundwater runoff")           {   water / tc_g   }
	}
	
	
	#TODO Ice & snow sublimation?
	
	module("ArcticSnow", version(0, 0, 1)) {
	
		water_target : loc(glacier.water)
	
		par_group("Snow") {
			ddf0_melt : par_real("Degree-day factor for snowmelt", [m m, deg_c-1, day-1], 2.74, 0, 5, "Linear correlation between rate of snow melt and air temperature")
			t_snow    : par_real("Temperature at which precip falls as snow", [deg_c], 0, -4, 4)
			t_melt    : par_real("Temperature at which snow melts", [deg_c], 0, -4, 4)
			refr_eff  : par_real("Refreeze efficiency", [], 0.5, 0, 1, "Speed of refreeze of liquid water in snow relative to speed of melt at the opposite temperature differential")
			snow_liq  : par_real("Liquid water fraction", [], 0.1, 0, 1, "How many mm liquid water one mm of snow (water equivalents) can hold before the water is released")
			init_snow : par_real("Initial snow depth (water equivalents)", [m m], 0, 0, 50000)
			
			fall_factor : par_real("Snow fall correction factor", [], 1, 0, 1)
		}
		
		par_group("Snow facing", snow_box) {
			facing_melt_factor : par_real("Facing melt factor", [], 1, 0.1, 1)
		}
	
		var(snow_box.snow.temp, [deg_c], "Snow temperature") {
			last(temp) + (air.temp - last(temp))*0.4   #TODO!
		}
		
		var(snow_box.ddf, [m m, deg_c-1, day-1], "Snow melt degree-day factor") {
			facing_melt_factor * ddf0_melt #TODO maybe also radiation something
		}
		
		var(snow_box.snow,  [m m], "Snow depth") @initial { init_snow }
		var(snow_box.water, [m m], "Snow water")
		
		flux(nowhere, snow_box.snow, [m m, day-1], "Precipitation falling as snow") { fall_factor * air.precip * (air.temp <= t_snow)  } # Making use of auto-cast of boolean->real
		
		flux(nowhere, water_target, [m m, day-1], "Precipitation falling as rain")  {  air.precip * (air.temp > t_snow)  }
		
		melt :
		flux(snow_box.snow, snow_box.water, [m m, day-1], "Melt")       {   max(0, ddf*(snow.temp - t_melt))   }
		
		refreeze :
		flux(snow_box.water, snow_box.snow, [m m, day-1], "Refreeze")   {   max(0, refr_eff*ddf*(t_melt - snow.temp))  }

		melt_runoff :
		flux(snow_box.water, water_target, [m m, day-1], "Melt runoff") {   max(0, water - snow*snow_liq)*1[day-1]  }
		
		discrete_order {
			#TODO: we also want to be able to specify special placement of add and sub instructions for these if necessary. But not for this module.
			melt
			refreeze
			melt_runoff
		}
	}
	
	module("SimplyGlacier", version(0, 0, 1)) {
		
		ice_epsilon : constant("Ice epsilon", [m m], 1e-6)
		
		par_group("Glacier global") {
			K_min   : par_real("Glacier runoff coefficient min", [day-1], 1)
			K_range : par_real("Glacier runoff coefficient range", [day-1], 0)
			A_G     : par_real("Glacier runoff snow dependence", [m m-1], 0)
			perc_frac : par_real("Percolation fraction", [], 0.1)
			ddf_ice : par_real("Relative degree-day ice melt", [m m, deg_c-1, day-1], 1)
			snowtoice : par_real("Glacier accumulation coefficient", [day-1], 0, 2.7e-4, 1e-3)
		}
		
		par_group("Glacier", glacier) {
			init_ice : par_real("Initial ice thickness", [m m], 0)
		}
		
		var(glacier.ice, [m m], "Glacier ice") @initial { init_ice }
		
		var(glacier.water, [m m], "Glacier melt water")
		
		var(glacier.ice.temp, [deg_c], "Ice temperature") {
			air.temp  # TODO
		}
		
		
		flux(snow_box.snow, glacier.ice, [m m, day-1], "Glacier accumulation") {
			snowtoice * snow if last(glacier.ice) > ice_epsilon,
			0                otherwise
		}
		
		flux(glacier.ice, glacier.water, [m m, day-1], "Glacier melt") {
			#ddf_ice := aggregate(snow_box.ddf) * ddf_ice_fac,
		
			0                     if aggregate(snow_box.snow) > ice_epsilon,
			max(0, ddf_ice*temp)  otherwise
		}
		
		#TODO: Sublimation!
		
		var(glacier.water.flow, [m m, day-1], "Glacier water flow") {
			water * (K_min + K_range * exp(-A_G * aggregate(snow_box.snow)))
		}
		
		flux(glacier.water, river.water, [m m, day-1], "Glacier runoff") {
			(1-perc_frac)*flow if ice > ice_epsilon,
			0                  otherwise
		}
		
		flux(glacier.water, soil.water, [m m, day-1], "Glacier percolation") {
			perc_frac*flow                            if ice > ice_epsilon,
			in_flux(water)                            otherwise
		}
	}
	
	
}
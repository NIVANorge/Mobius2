




	# We could maybe signal in the flux declaration if it is allowed to be bidirectional. Then give an error for that for fluxes that can't be bidirectional.
	biflux(...) {
	}
	# Debatable whether we should then clamp other fluxes to min 0.
	
	


	horz : connection("Fjord horizontal") { (layer|bnd_layer)* }

	var(layer_water.horz_target, [])
	
	# Last arg says that this is called per horz index.
	# However this is a bit wrong because we don't know that the first component is always "layer", could also be "bnd_layer"...
	# I guess we just make this a template that we apply both for layer and bnd_layer.
	
	special_computation("Place horizontal fluxes", "nivafjord_place_horizontal_fluxes", horz) {
		layer.water.horz_target
		layer.water.dens[horz.below]
		layer.water.dens
		w_bnd
	}
	
	flux(layer.water, layer.water[horz, vert2.specific], [k g, day-1], "Flow from boundary") {
		bcl := -(layer.water.barocline_bnd_u + layer.water.barotropic_bnd_u)->>,    # Hmm, these have to exist per horizontal connection also.
		bcl    if bcl > 0,
		0      otherwise
	} @specific {
		layer.water.horz_target[horz]
	}








	
	# Want module parameters in the form of constants, and also if conditions
	
	# Since enum parameters are baked constants..
	par_group("SimplyQ setup choice") {
		etp_module : par_enum("Evapotranspiration module", degree_day) { degree_day penman_monteith }
	}
	
	# Then we don't need the separate option system.
	
	if(etp_module.degree_day) {
		load("...")
	}
	if(etp_module.penman_monteith) {
		load(atmospheric,...)
		load("...")
	}
	# This is probably the best system!
		# Need to read values directly from the dataset, but that should be ok. The dataset can be loaded first independently.
	
	
	
	
	
	
	if(some_bool_const) {
		# Stuff
	}
	#etc.
	
	# Model options, that can be configured in the dataset
	option_set("Evapotranspiration module") {
		option("Degree-day") {
			load(bla bla bla)
		}
		option("Penman-Monteith") {
			sw : property("Shortwave radiation")
			etc..
			load( p-m)
			load( atmospheric )
		}
	}
	
	#Dataset:
	
	option_set("Evapotranspiration module") [ "Degree-day" ]
	
	
	



	# Musings:
	#
	# directed_tree connections are in some ways very different from grid1d and all_to_all since the target is unspecified. Complicates the system a bit..
	#
	flux(layer.water, layer.water[vert.below], [m 3, day-1], "Mixing down")     # Makes sense, should maybe be equivalent to just saying 'vert'
	
	# Here we can't do it that way since there could be multiple targets. Also, if we were to be able to reference 'below' inside the code here, it would have to generate different code for the index depending on the target (which we maybe will do for graph connections).
	flux(river.water, downstream, [m 3, s-1], "Reach flow")
	



	{
		horz_target : property("Target of horizontal flux")
		var(layer.water.horz_target, [], "bla")
		
		special_computation("Place horizontal fluxes", "place_horizontal_fluxes", ) {
			#TODO: Make it something like this instead so that a special_computation could have several outputs.
			out(layer.water.horz_target)
			layer.water.dens
			bnd_layer.dens
			# could also have e.g. constants etc.
			5.0
		}
	
		# Something like this ?
		flux(bnd_layer.water, layer.water[vert.horz_target], [k g, day-1], "Boundary exchange")
		
		# Implying that layer.water.horz_target gives the index along the vert connection where the target goes.
		# Although wouldn't it just be better to allow any expression there (at least in code) ??
		# 		Would not work for target of 
		
		layer.water[vert{ horz_target }]     # ???
		
		# Maybe not..
		
		# Is this really extendable to when we need to smooth it out over triangle though??
		
		# Maybe better. Then if there is just one expression in the target it sends it there, if there are three, it smooths it out.
		flux(bnd_layer.water, layer.water[vert.specific], ...) {
			bla
		} @specific {
			horz_target[vert.above]
			horz_target
			horz_target[vert.below]
		}
	}
	
	
	
	
	
	
	# Fine-grained time of day:
	time.second_of_day + time.step_length_in_seconds * time.fractional_step
	# Should this one always be available? As
	time.integrated_s_o_d # (?)
	
	
	
	
	
	
	# Code for sending things to computed indexes.
	
	flux(layer.water, horz, [k g, day-1], "Horizontal exchange") {
		dP := pressure - pressure[horz.next]  #NOTE: this is not the same as the one below because there you also look over all the vertical indexes.
		#...
	} .to_index.vert.smallest { # This is the vertical index, not the horizontal one
		abs(pressure - pressure[vert, horz.next])
	}
	
	# Actually need to be able to distribute over multiple indexes when two neighboring layers are split apart.
	.smallest_distribute   # ??
	
	# This one reuses []-syntax, and is probably better (?) No need to put an identifier as a note (which is a bit of a mix of syntax concepts)
	flux(layer.water, connection[horz, vert.select], [k g, day-1], "Horizontal exchange") {
		#..
	} .select_minimize_convex .distribute {
		abs(pressure - pressure[horz.next, vert.select])
	}
	
	
	
	#In general, the connection target should be connection[horz] instead of just 'horz' as the argument to the flux?
	
	
	
	
	
	# Maybe need specialized functionality for wind driven mixing
	
	mix(layer.water, vert) .avail_energy {
		oair.emix
	} .need_energy {
		grav*ddens[above]*(sumV[above]*V/(sumV[above]+V))*z/2
	}
	
	# Alternative, need imperative programming:
	
	code() {
		for vert {
			
		}
	}
	

	
	
	
	
	# Could we get rid of a.b.c.decl() type chained declarations altogether ? Could simplify syntax a bit
	# e.g.
	
	par_group("Bla", soil)
	# Easier to extend if we want something to covary over soil and contaminant type for instance.
	# After the change it seems like it will be mainly par_group, distribute and solve that use these. (Getting rid of or transforming 'to' and no_carry)
	
	distribute(soil, landscape_units, reaches)   # Makes it not immediately as clear what is being distributed over what...
	solve(simply_solver, soil.water, river.water, gw.water)  # Varargs so that you can pass multiple
	
	
	
	
	# Main problem with solution below is that it is error prone to pass the arguments correctly.
	# E.g. easy to pass two compartments in the wrong order.
	# How to solve?
	# Maybe we just live with it?
	
	# For things like EasyLake there will be a lot passed that is just atmospheric for instance. Could these be packed into "structs" or "var_groups" ?
	
	
	# Need a (new) system for a model extending another to override stuff from that.
	# esp. for connection declarations.
	
	
	# How to disambiguate loads of the same module when it in theory could be loaded multiple times?
	# guess we give the load a name?
	
	load("file_name.txt", module("Template name", "Specialization name", args..) # ??
	
	# Then this is the name that is used for serialization.
	# Omitting the specialization name then uses the template name for the specialization name (and blocks multiple loads of the same thing).
	# Only downside is that if we try to load the same module with the same name but different arguments, we don't get a warning or error.
	
	# Should we do it differently?
	load("file_name.txt", module("Template name", "Specialization name") {
			soil, gw, pet              # This just passes the symbols from the parent scope into the module scope. And only if we need to we could have a module argument that specializes something (?)
		}, ..)
	# Doesn't quite work for flux targets though, those would always have to be arguments.
	
	
	
	
	flux(nowhere, layer.water.heat, vert, "Latent heat flux") .top {}
	# Would probably be clearer as:
	flux(nowhere, layer.water.heat, vert.top, "Latent heat flux") {}
	# Although, see below.. Could change it completely.
	
	
	# In this case it makes sense to separate out the gw in a separate module also.
	
	module("SimplyQ soil", version(1, 0, 0),
		soil  : compartment,
		gw    : compartment,
		water : quantity, 
		pet   : property,
		# could also have e.g. a_catch : par_real,
		soil_target : loc, 
		gw_target : loc) {
		
		soil.par_group("Hydrology") {
			
		}
		
		var(soil.water, [m m], "Soil water volume") .initial { fc }
		
		flux(soil.water, soil_target, [m m, day-1], "Soil runoff") {
			#...
		}
		
		flux(soil.water, out, [m m, day-1], "Evapotranspiration") {          # 'out' now means the same as 'nowhere' did before, while there is no new 'out'
			#...
		} @no_carry { }
	}
	# How we would specify no_carry is still a bit in the air. Probably we have a  @no_carry{ } body on the flux. Then the arguments to that are passed to the module.
	
	module("HBV Snow", version(1, 0, 0),
		air : compartment,
		precip : property,
		temp : property,
		water_to : loc) {
		
		snow_box : compartment("Snow box")     # If nothing tied to it is exported, we could just declare it locally (although it is used in soil.temp, so we can't actually do it in this example)
		#...
		
		flux(out, water_to, [m m, day-1], "Precipitation falling as rain") {
			precip * (air_temp >= 0)
		}
		
		
	}
	
	# Implemented by importing the passed arguments to the scope of the module.
		# Need special mechanism for having a single identifier refer to a chained location, and that needs to work in all places where you can resolve it.
		#   (could just make an entity type for it, but still have to fix the places where resolution happens)
	# Could also allow assigning these to handles when we do var declaration:     a : var(b.c, ....)
	
	# Also want the ability to let a par group be global (not attached to a specific thing?). In that case it is not duplicated if it is loaded several times.
		# It must actually also be de-duplicated based on the component it is attached to (if module is applied multiple times with that same component as the same argument).
	
	# Still possible to declare properties within modules if you only want to use them there. Maybe also compartments and quantities.
	
	model("SimplyQ") {
	
		air    : compartment("Atmosphere")
		soil   : compartment("Soil")
		gw     : compartment("Groundwater")
		
		water  : quantity("Water")
		
		pet    : property("Potential evapotranspiration")
		precip : property("Precipitation")
		temp   : property("Temperature")
		
		# Declare input series in the model (?)
		var(air.precip, [m m, day-1])
		var(air.temp, [deg_c], "Air temperature")
		
		# Should we have a system for declaring what variables we expect each module to construct ?
		
		load("simplyq.txt", 
			# This is a bit hazardous, you could easily misplace something when so many are of the same type.
			# And for larger modules, you will need to pass a lot of stuff!!
			module("SimplyQ soil", 
				soil, gw, 
				water, 
				pet, 
				river.water, river.water),
			module("SimplyQ river", river, water, downstream)
		)
			
		# Can then also apply a module as a template to several things.
		load("photomineralize.txt",
			module("Photo-mineralize", oc, epi.water.oc, air.grad),
			module("Photo-mineralize", oc, river.water.oc, air.grad),
			module("Photo-mineralize", oc, layer.water.oc, layer.par)
		) # Would have to make it so that par groups attached to oc in the module are de-duplicated.
		
		load("airsea.txt",
			module("Air-sea", air, layer.water[vert.top], ..),
			module("Air-sea", air, epi.water)
		)
		
		something() {
			soil.fc    # Want scoping of parameters to their component (but inferrable in most cases). Should we also consider full location of par groups like soil.water.par_group() ?
		}
		# General model parameters are passed in using the passing system
	}
	
	# Need top and bottom of grid1d to be valid locations that can be passed around (and used directly where other locations can)
	# Something like
	layer.water.heat[vert.top]  # More easily shorthanded (see below)
	
	#Then boundary fluxes are
	flux(nowhere, layer[vert.top].water.heat, "Shortwave")   #etc.
	# and above, below etc. becomes
	layer[vert.above].water.bla
	# In this case the post-indexing could be better so that we don't have to write the entire thing
	bla[vert.above]
	bla[vert.top]
	
	
	# Would need par groups to be scoped to their component in the data

	module("Bla") {
		par_group("Epilimnion", "Bla") {
		}
		par_group("River", "Bla") {
		}
	}
	# or (make it closer to the connection system)
	epi : compartment("Epilimnion")
	module("Bla") {
		epi.par_group("Bla") { ... }
	}
	
	#serialize :
	# State var serialization name is
	"River:Water"
	"Soil:Water:Organic carbon"
	# etc. Need to disallow : in names
	
	# Not sure if this is used for input series and MobiView display though..
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	layer.has(absorbed_sw : property("Absorbed shortwave") {
		sw * exp(-attn*z)  #Or something..
	} .top_boundary { 0 }
	
	layer.has(sw : property("Incoming shortwave")) {
		above(vert, sw) - above(vert, absorbed_sw)
	} .top_boundary { net_sw*A }
	
	flux(nowhere, layer.water.heat, "Shortwave heat flux") {
		absorbed_sw
	}
	
	#Or   (starting to break rules about referencing fluxes)
	sw_transfer :
	flux(layer.water.heat, vert, "Shortwave transfer") {
		in_flux(sw_transfer) * exp(-attn*z) * target(A)/A		#TODO: Is area adjustment correct?
	} .top_boundary {
		A * net_sw
	}
	# Still need to do something when we want to know the absorbed sw for photo-degradation purposes though...
	# Like in_flux(sw_transfer) also being available in other equations.
	
	# Also:   (always just resolved for the one layer, not on an iteration loop), but then need to actually set the index for that layer
	flux(layer.water.heat, vert) .top_boundary {
		A * net_lw
	}
	
	# Problem with this one is that it should go somewhere... (i.e. to sediment thermal energy).
	flux(layer.water.heat, vert) .bottom_boundary {
		# Whatever exchange between water and sediment
	}
	
	#flux(layer.water.heat, sediment.heat, vert) .bottom_boundary     # Not that intuitive, but maybe the best of the suggestions any way?
	#flux(layer.water.heat, sediment.heat) .bottom_boundary(vert)     # Introduces new syntax. Should maybe be avoided.
	#flux(layer.water.heat, vert.bottom, sediment.heat)               # Hmm.
	
	# Also lends itself to (This particular example is not relevant though)
	#flux(air.heat, layer.water.heat, vert) .top_boundary
	
	# Then should maybe also have
	#flux(nowhere, layer.water.heat, vert) .top_boundary
	# for the other ones, but that is also not that intuitive ??
	
	# What about
	#flux(somewhere.heat, layer.water.heat, sediment.heat, vert) {} .top_boundary {} .bottom_boundary {}  # etc. Should be OK.
	
	
	# Or just force separate declarations for the boundaries always??
	sw_transfer :
	flux(layer.water.heat, vert, "Shortwave transfer") {
		in_flux(sw_transfer) * exp(-attn*z) * target(A)/A		#TODO: Is area adjustment correct?
	}
	
	flux(nowhere, layer.water.heat, vert, "Shortwave to water") .top_boundary {
		A * net_sw
	}
	
	# Could make it easier to keep track of the various "Locations"
	# No, doesn't work because in_flux(sw_transfer) also needs to be able to refer to the boundary! (although that causes a complexity in itself...)
	
	# Would be easier to implement if you had just in_flux(layer.water.heat, vert_sw), but then you would need a separate connection for the shortwave transfer so that it
	# gets its own aggregation variable. Maybe that is what we do though.
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	# Unit checking
	
	# Always declare assumed unit of flux ?
	flux(soil.water, out, [m m, day-1], "Soil water flow") {
		#etc.
	}
	# No, causes too much repetition.
	# How do we catch errors on expected units though??
	# Do we want to allow it in some cases?
	
	# For converting in-side equations
	{
		convert(a, [m g, l-1]) # applies some kind of unit conversion term
		force(a, [m g, l-1])   # Just sets the unit while keeping the same numerical value.
		force(a)               # forces to the unit of whatever we are resolving.
	}
	# Can we come up with less intrusive syntax?
	#e.g.
	{
		[m g, l-1]a      # convert
		a -> [m g, l-1]  # convert
		a => [m g, l-1]  # force
		a ->>            # convert to result unit
		a =>>            # force to result unit
		#![m g, l-1]a   # Guess "force" is ok also since it is not that common
	}
	
	# could we have a shorthand for things like
	(0.5 => [deg_c])
	#like
	0.5 [deg_c] # ??
	



	# Sub-indexed index set. Only allow one sub-indexing for now (I.e. not sub-indexed of sub-indexed)
	# Also need to check distributions so that anything that depends on the sub-indexed one also depends on the parent.
	
	layer : index_set("Layer index", lake) 
	
	# in data set:
	
	#index_set("Layer index") [ "Lake" : "Vansjø" ] [ 100 ]
	
	index_set("Layer index", "Lake") [
		"Vansjø" : 100  
		"Store" : 70
		"Bing" : ["a", "b", "c"]        # Dunno if we should allow mixing of types.  --- Maybe the easiest to just allow numeric type for now.
	]   #Maybe better, so no need to redeclare each one.
	
	
	
	std::vector<std::vector<Index_T>> index_counts;
	
	Index_T get_index_count(Entity_Id);
	Index_T get_index_count(Entity_Id, Index_T);
	

	# Graph type connections
	# 	specify pairs    node - vertex                (though the vertex may not always have to be a separate compartment. Could then just be the node)
	#   what to do about directedness?
	
	net : connection("Drainage network", graph) {
		(((node|storage_unit|divider) conduit) | (node regulator) | (storage_unit pump))*
	}

	connection("Network") {
		n : compartment("Node")
		c : compartment("Conduit")
		
		n["N1"] - c["C1"] - n["N2"]
		n["N1"] - c["C2"]            # Allow multiple outgoing connections per node.
	}
	
	flux(node, net, "Flow") {
		something * target(something_else)        # Here the framework would need to check that something_else is valid for each possible target (e.g. check each possible pair where the first is node.)
	}
	
	# Technicalities:
	# 	We get one instance of the flux per outgoing connection. How do we index that? That does not fit within the existing indexing system.
	#      May have to generate a special index set for this (actually one per node type), and it is separate per node (sub-indexed).
	
	
	
	# 1D diffusion flux.
	
	c : connection("Layers", grid1d)
	flux(layer.o2, c, "O2 diffusion") {
		d := 0.5*(dc + target(dc))
		h := 0.5*(th + target(th))
		d(o2 - target(o2))/h
	}
	layer.has(o2conc : property("O2 conc")) {
		o2 / th
	}
	



	# Better syntax for variable declarations than 'has' (?)
	var(soil.water, unit(m m), "Soil water volume")

	# What about inlined declarations then...
	var(soil.temp : property("Temperature"), unit(deg_c), "Soil temperature")
	# Breaks current restrictions. It is not soil.temp that is declared as the property, but temp.
	# Do we need to keep the inlined declarations ?
	# Not that much more work to write, and it is maybe even cleaner. Could we get rid of inlined declarations altogether (except for units, which we could do differently anyway)?
	# 	Would simplify model declaration code.
	temp : property("Temperature")
	var(soil.temp, unit(deg_c), "Soil temperature")
	
	# Special syntax for unit declarations:
	[m m], [m 3, s-1]  #etc. 
	# Make them their own AST type. (Clean up Argument_AST)
	
	var(soil.temp, [deg_c], "Soil temperature")



	# How to handle aggregation weights (and unit conversions) for connections.
	
	soil_flow : connection("Soil flow", directed_tree) { soil* river }
	
	aggregation_weight(soil, river) { lu_prop }
	unit_conversion(soil.water, river.water) { a_catch * 1000 }   #TODO: when we get automatic unit checking we should remove the 1000 !
	
	# Should we need to specify that the aggregation weights are to be used for the connection, or is that automatic whenever such a connection is possible?
	# 	full automatic is too problematic because you also need weighting between different land use types.
	# Just need to be able to add
	
	aggregation_weight(soil, soil) { lu_prop / to(lu_prop) }



	# all_to_all   connection:

	# Module

	habitat.par_group("Migration") {
		mig_wt : par_real("Migration weight")
	}
	
	flux(habitat.pop, out) {
		0.5 * (pop - to.pop) * mig_wt
	}
	
	# Model:
	
	mig : connection("Migration path", all_to_all) { habitat }
	
	# 'to'   could be a stand-in in any flux for the compartment of the target of the flux (maybe). At least if the target is a connection.
	# If it is just the compartment, what if we later allow connections between different quantities (?)
	
	# mig_wt is first indexed by the source, then the target (if it has a double indexing over one of the index sets)

	### In data:

	par_group("Migration") ["Habitat index", "Habitat index"] {
		par_real("Migration weight") [
			0   0.1 0.3
			0.5 0   0
			0.1 0.2 0
		}
	}
	
	# Should not specify connection data for this type since it is all_to_all.
	
	# Actually, may want to specify what index set the all-to-all is over... Is it better to do it in data to be consistent, or should it just be done in the model file?
		# in case habitat is distributed over several index sets, but we only want the connection over one of them
		
		# Model
			mig : connection("Migration path", all_to_all, habitat_index) { habitat }
		# Data
			h : compartment("Habitat") [ "Migration index" ]
			connection("Migration path") [ h ]
	# The latter one is better if we want to extend it to multiple compartments (need union index sets to specify weights in that case) or to multiple index sets.
		# Should not be supported immediately, but 
		
	### Implementation side:
		Batch and Model_Instruction needs to be able to have double dependencies 




	# TODO: for connection data, instead of storing the index, we probably have to precompute and store the actual offset of the aggregation variable.
	# That gives a very high-dimensional array in some cases though... But probably works fine.
	# Otherwise we don't know what var_id_agg we need to look up from, when it could be multiple.
	#	Hmm, we need the var_id_agg anyway since there could be different weighting/unit conversions for different targets!
	#	This is kind of tricky.
	#	Connection data must be:
	#
	#	For each connection
	#		for each compartment in the connection (index tuple)
	#			what does it point at (offset + info about weighting)
	#
	#	Connection_T is { connection_id, compartment_id, (maybe info point id, but we can ignore that for now?) }
	#
	#	Data is s64   . Could try to pack target offset and target id into the same thing. It is unlikely that we need more than s32 to store the offset (and we could guard for it).
	#		However that complicates the code a bit since we need to do the extraction in llvm.
	#       Alternative is to make two info points.
	#       Actually, we don't pack in the target id, we just pack in a number that identifies what weight / unit conv. computation to use.
	#
	#       Get to work first: just store the offset, worry about weighting later.
	#
	#		Ouch, no, it becomes circular...
	#		We have to set up the neighbor data in order to compile the model, but we need the model compiled before we can find the offset to the target.
	#		What do we do instead ? Store target id AND indexes ?

	# New idea:
	# 
	# We don't have neighbor relations between index sets, we have them between compartments. Also rename to connection
	# e.g.
	#
	#    *********  this first part is first priority! Make the other ones work later.
	
	# Things to do to get this to work
	# 	- store connection offsets instead of connection indexes (see above note)
	#   - make connections be between compartments instead of between indexes.
	#	- change the data format. (+ decide how it should be!)
	
	downstream : connection("Downstream", directed_tree) { (river|epi)* }  # 0 or more rivers or lake epilimnions interchanged.

	# in data file:

	r : compartment("River")
	l : compartment("Lake")

	# this doesn't allow us to do checking of indexes belonging to index sets, but that is maybe ok?
	connection("Downstream") [
		r"Coull" -> r"Boyne" -> l"Somelake"
	]
	
	#do we instead have to declare
	r : compartment("River")[ "Subcatchment" ]
	s : compartment("Soil")[ "Subcatchment" "Landscape units" ]
	# that may be a bit annoying, but gives much more flex! And declares the index order locally, which is good!
	# This could also allow us to not have to index all the indexes if some of them are to be implicit!
	
	#    *********  end first priority
	
	
	

	# model file :
	soil_flow : connection("Soil flow", directed_tree) { soil+ river }  # 1 or more soil boxes followed by a river.

	# data file :
	s : compartment("Soil")

	connection("Soil flow") [
		s."Forest" -> s."Bog" -> r.         #This means for all subcatchment indexes ... Could maybe even omit the 'r.' since it is necessary by the model spec. '.' is to say that it is the wildcard
		s"Coull""Forest" -> r"Coull"        #This means for this subcatchment in particular..  Have to have the indexes in right order as distributed
		s"Boyne". -> r.                     #All land units in this subcatchment go to the river.
	]


	# layered lakes
	
	lake_index  : index_set("Lake")
	layer_index : index_set("Lake layer", lake_index)  # Separate instance of it per lake_index (?)
	
	lake_layer.distribute(lake_index, lake_layer)
	lake_sediment.distribute(lake_index)
	
	lake_layering : connection("Lake layering", grid_1d) { lake_layer* }
	
	# data file :
	
	index_set("Lake layer") [ "Somelake" : enumerate(50) ]   # indexes are numeric from 0 to n-1   (n=50)

	#connection("Lake layering")
	# In this case the connection can be inferred since there is only one lake_surf and one lake_bottom per "Lake", and the lake_layers are already enumerated in order.
	
	l : compartment("Lake layer")
	
	connection("Downstream") [
		r"Coull" -> r"Boyne" -> l"Somelake"0    # 0 is the 0th layer of the lake. Missing indexes could default to 0?
	]
	# Could also allow to refer to the label here (see below)
	
	
	# To make specific processes for the top layer: Need something called 'labeled' where you label one of the compartments.
	top_layer : layer.labeled("Top layer")
	
	flux(nowhere, top_layer.heat, "Surface heat flux")
	
	# in data file
	labeled("Top layer") [ "Some lake":0 ]    # or just [ 0 ] if it is the same for all of them.
	
	# Connection flux between two layers..
	flux(lake_layer.water.oc, lake_layering, "Diffusion") {
		#etc.
		# refer to the two compartments by 'first', 'second'
	}
	
	



	# Rethinking the entire index set system?
	
	# Fundamental need is to have some kind of distribution that you distribute things over to create copies of the same sub-model specification.
	# + connectivity between different things.
	
	# Rename "neighbor" to "connectivity" ?

	# System accomodates different kinds of specifications:
	#	- distribution of things that work in parallel
	#   - specific connection of one system into a part of another.



	#Non-unique names of entities, can instead in model scope:

		soil : identify(sw.soil, pe.soil, sn.soil)

	#problems
	#	- can be clashes between different names in different modules.
	#	- parameters still have to have unique names within their parameter group.
		
	#Alternative:	
	#	- fully use the (yet to be designed) template system for everything that is not hydrodynamic.


	# Replace
	downstream : sc.neighbor("Downstream", directed_tree)

	# With?
	
	lake_layers : index_set("Lake layers", one_dimensional)
	
	lake : lake_layers.distribute() { lake_top_layer lake_layer* lake_bottom_layer }
	
	
	# regex format :
	# a b   a followed by b          - prioritize
	# ? zero or one of preceding
	# * zero or more of preceding    - prioritize
	# + one or more of preceding
	# a|b  a or b                    - prioritize
	# ()  operator precedence        - prioritize
	# (all symbols a b c etc. are names of compartments (or compartment groups if we make that))
	
	neighbor("Downstream", directed_tree) { (river|epi)* }
	
	
	
	
	
	downstream : neighbor("Downstream", directed_tree)
	
	rw.reach_out.to(downstream)
	lw.lake_out.to(downstream)

	# in data:
	
	neighbor("Downstream") [
		"r1" -> "r2" -> "l1":0 -> "r3"
		"ar1" -> "ar2" -> "l1":0
	]


	downsoil : neighbor("Soil flow path", directed_tree)
	
	sw.soil_runoff.to(downsoil, river.water)  # Default is to send it to river.water (if no other is given).


	
	soilc : template("Soil carbon processes")

	soilc.par_group("DOC general") {
		cdoc       : par_real("Baseline soil DOC dissolution rate", unit(m g, l-1, day-1), 1, 0, 10)
		#etc
	}

	soilc.water.has (oc, unit(k g, k m -2), "Soil water DOC") .initial_conc { basedoc }

	flux(nowhere, soilc.water.oc, "Soil DOC production") {  max(0, water*cdoc*(1 + temp*(kt1 + kt2*temp) - kso4*air.so4))  }
	
# In model
	soil.apply(soilc)
# or:
	
	pm : template("Photo-mineralization")
	
	pm.par_group("Photo-mineralization") {
		cs : par_real("Optical, cross-section", unit(n m), 0)
	}
	
	flux(pm, nowhere, "Photo-mineralization") {   #Non-uniqueness of names is exacerbated
		# some formula
	}
	
# then
	river.water.oc.apply(pm)
	lake.water.oc.apply(pm)
# Issues:
	# In the second example, the process is tied to a specific location, instead of being able to talk to different locations inside the same compartment. Could be nice.
	
	# But gives potentially too many instances of the same par group. (actually in both examples) E.g in this case it is clear that we only want one instance of optical cross-section.
	
	# The multiple instances are not index sets, so we can't just limit the distribution of the par_group, there is actually a separate instance per 'uses'.
	
	# Solution:
		# make index_set like mechanic for this?
		
	
	
	

# What about instead of having

	soil.has(temp, unit(deg_c), "Soil temperature") {
		#bla
	}
	
# We have

	soil.temp.exists(unit(deg_c), "Soil temperature") {
		#bla
	}
# or
	create(soil.temp, unit(deg_c), "Soil temperature") {
		#bla
	}
	

# Then the entire location name "soil.temp" appears as one, and is easier to search for








fjord_arm : (top_water middle_water* bottom_water).distribute_unique(fjord_layer)
((river|lake)* fjord_arm).distribute(sc)

downstream : sc.neighbor("Downstream", directed_tree)

# How to link it up when river arrives in fjord/lake ?
# If it is statically determined, ok, but what if it requires a computation?





    # For initial groundwater flow, could we do something like
	#     .initial { out_flux(target(gw_runoff)) * tc_g }
	# where target(x) is the located quantity of the flux target (which is not resolved in this module)
	# Would mean that this module doesn't need to explicitly know about what happens in the target to set initial steady state.
	# Is a bit tricky since one would have to know to invert the unit conversion. Also, what happens if the target is a fjord and not a river?
	# Alternative
	#     .initial { steady(gw_runoff)*tc_g }
	# where steady(flux) tries to compute what value of gw_runoff is needed to put the target in steady state.
	# Also tricky since it would have to invert the equation for the target.
	# What about
	#	  .initial { inv_convert(target(gw_runoff).flow) * tc_g   if exists, (whatever) otherwise }
	# where exists evaluates to true at compile time if the lhs exists.  This is probably a good option. Still a lot of work to implement...




module("HBVSnow", 1,0,0) {
"""
Some description in markdown.
"""
	air        : compartment("Atmosphere")
	snow_box   : compartment("Snow box")
	
	snow_par :
	snow_box.par_group("Snow") {
		"""
		Maybe allow a description per par group too, giving a better summary of how to use it. Can be shown in tooltip.
		"""
		ddf_melt  : par_real("Degree-day factor for snowmelt", unit(m m, deg_c -1, day -1), 2.74, "Some description")
		t_snow    : par_real("Temperature at which precip falls as snow", unit(deg_c), 0)
		t_melt    : par_real("Temperature at which snow melts", unit(deg_c), 0)
		refreeze  : par_real("Refreeze efficiency", unit(), 0.5)
		snow_liq  : par_real("Liquid water fraction", unit(), 0.5)
		init_snow : par_real("Initial snow depth (water equivalents)", unit(), 0)
	}
	
	snow  : substance("Snow (water equivalents)")
	water : substance("Water")
	
	temp   : property("Temperature")
	precip : property("Precipitation")
	
	# Or should these two be external to the module?
	air.has(temp,   series("Air temperature", unit(deg_c)))
	air.has(precip, series("Precipitation", unit(mm, day -1)))
	
	snow_box.has(snow,  unit(m m)) initial { init_snow }
	snow_box.has(water, unit(m m)) initial { 0 }             # Not necessary to declare initial here, default is 0.
	
	# Source void means that we are not interested in tracking the state of the source, this is then a pure source to the system
	flux(void, snow_box.snow, "Precipitation falling as snow") {
		air.precip    if air.temp <= t_snow,
		0             otherwise
	}
	
	p_rain :
	out_flux(void, "Precipitation falling as rain") {       # out_flux means that this module does not know what the target is. The target has to be linked in the model composition later.
		air.precip    if air.temp > t_snow,
		0             otherwise
	}
	
	flux(snow_box.snow, snow_box.water, "Melt") {
		min(max(0, ddf_melt*(air.temp - t_melt)), last(snow_box.snow))
	}
	
	# It would be good if we don't have to declare min(..., last(snow_box.water)) here and instead have it automatic, but it would make order of evaluation of refreeze and melt_runoff ambiguous. Can we figure out a way to make this more clean?
	
	flux(snow_box.water, snow_box.snow, "Refreeze") {
		min(max(0, refreeze*ddf_melt*(t_melt - air.temp)), last(snow_box.water))
	}
	
	melt_runoff :
	out_flux(snow_box.water, "Melt runoff") {
		max(0, snow_box.water - snow_box.snow*snow_liq)
	}
}

module("Degree-day PET") {
"""
Very simple evapotranspiration module.
"""
	air : compartment("Atmosphere")
	soil : compartment("Soil")
	
	temp : property("Temperature", unit(deg_c))
	pet  : property("Potential evapotranspiration", unit(m m, day-1))
	
	soil.par_group("Potential evapotranspiration") {
		ddf_pet   : par_real("Deegree-day factor for evapotranspiration", unit(m m, deg_c -1, day -1))
		pet_min_t : par_real("Minimal temperature for evapotranspiration", unit(deg_c))
	}
	
	# Not declaring that air.has(temp) here makes this module incomplete on its own (what is the source of the value?), but it is sufficient that it is composed with some other module that declares it.
	# This means that this module does not have to know that air.temp is an input series. Can be useful in some more complicated cases where there is some value that can be either an input series or
	# computed depending on what other modules are used.
	
	soil.has(pet) {
		max(0, ddf_pet*(air.temp - pet_min_t))
	}
}

module("SimplyQ soil", 1,0,0) {
"""
Insert module description in markdown
"""
	soil    : compartment("Soil")
	aquifer : compartment("Aquifer")
	
	# We attach this first parameter group to the soil - even though it is the same for the entire catchment - since it is used in computations regarding fluxes of soil water: But the model composition can re_index it so that it does not have to have all the index set dependencies of soil.
	hydr:
	soil.par_group("Hydrology") {
		bfi     : par_real ..
		f_quick : par_real ...
	}
	
	hydr_land :
	soil.par_group("Hydrology land") {
		tc_s    : par_real ..
		fc      : par_real ...
	}
	
	hydr_gw :
	aquifer.par_group("Hydrology groundwater") {
		tc_g    : par_real ..
	}
	
	water : substance("Water")
	
	soil.has(water, unit(m m)) initial { fc }
	aquifer.has(water, unit(m m))
	
	pet  : property("Potential evapotranspiration", unit(m m, day -1))
	
	evap :
	flux(soil.water, void, "Evapotranspiration") {         # Pure sink (target is void)
		soil.pet*(1 - exp(log(0.01) * soil.water/fc)
	}
	
	flow : property("Flow")
	soil.has(flow, unit(m m, day -1)) {
		max(0, (water - fc) / tc_s)
	}
	
	recharge :
	flux(soil.water, aquifer.water, "Groundwater recharge") {
		bfi * soil.flow
	}
	
	gw_flow :
	out_flux(aquifer.water, "Groundwater flow") {
		water / tc_g
	}
	
	lat_flow :
	out_flux(soil.water, "Lateral flow") {
		(1 - bfi)*flow
	}
	
	quick_flow :
	out_flux(soil.water, "Quick flow") {
		in_flux(soil.water) * f_quick                 # in_flux is the sum of all incoming fluxes of that substance to that compartment.
	}	
}

module("SimplyQ river", 1, 0, 0)
"""
etc
"""
	surf  : compartment_type("Surface water")
	river : compartment("River", surf)          # River is a "Surface water", and so is interchangeable with other compartments of this type (if we make a lake or reservoir for instance).
	
	water : substance("Water")
	surf.has(water, unit(m 3))
	
	# All surface waters have these parameters :
	surf.par_group("General catchment parameters") {
		catchment_area : par_real("Catchment area", unit(k m 2), 0, 0, 10000)
	}
	
	# Specific to rivers :
	river.par_group("Reach parameters") {
		slope          : par_real("Reach slope", unit(),  ...)
		len            : par_real ...
		c_mann         : par_real ...
		init_flow      : par_real ...
	}
	
	upstream_area : property("Upstream area", unit(k m 2))
	eff_len       : property("Effective length", unit(m))
	
	# Framework should be able to determine that this one is constant, and should only be evaluated at start of run
	river.has(upstream_area) {
		ca := sum_neighbors(catchment_area);
		up := sum_neighbors(upstream_area);
		ca + up
	}
	
	# Again, constant
	river.has(eff_len) {
		len * (upstream_area + catchment_area/2) / (upstream_area + catchment_area)
	}
	
	flow : property("Flow")
	river.has(flow, unit(m 3, s -1)) {
		val := water * sqrt(slope) / (eff_len * c_mann);
		0.28 * val * sqrt(val)                            #TODO: may have to do something with the unit here too.
	} initial {
		sum_neighbors(flow) if  neighbor_count>0,
		init_flow           otherwise
	}
	
	river.has(water, unit(m 3)) initial {
		depth := 0.349 * flow ** 0.34;
		width := 2.72 * flow ** 0.557;
		discard_unit(width * depth * len)      # It is not possible for the automatic unit checking to get this correct (unless we let 0.349 be a constant of unit m*(m^3/s)^-0.34 etc.
		                                       # discard_unit tells the unit checker to ignore that the unit is incorrect and just take the pure number and use it as if it had correct unit.
	}

	neighbor_flux(river.water) {
		from.flow                      # No unit conversion has to be declared (seconds to days). Is automatic by the unit checker. 'from' and 'to' are special keywords in the context of neighbor fluxes.
		                               # This would also allow the module to be completely time step independent (the model composition takes care of that).
	}
}


model("SimplyQ") {
"""
General model description.
"""
	
	time_step(unit(day))     # Could also have this not hard coded into the model, and instead be a choice at user interface level? (though requires input data to have a declared time_step).
	
	###### Import modules
	
	add_directory("../../Modules")
	
	# May want to eventually have a system for run-time choice of module, i.e one declares alternatives here, and these are selected by user when running model
	# We may even allow specifying specific versions here.
	
	include_module("hbv_snow.module", "HBVSnow")   # it should be in its own .module file, we just have everything in this file for convenience when displaying this example.
	include_module("pet.module", "Degree-day PET")
	include_module("simply_q.module", "SimplyQ soil", "SimplyQ river")
	
	###### Distribute modules over index sets and set solvers
	
	lu       : index_set("Landscape units")               # Simplest index set, where all indexes are considered neighbors (but this is usually not used)
	subcatch : index_set("Sub-catchment", flow_graph)      # flow_graph : Only neighbor flux from "upstream" to "downstream". Any trailing end also has neighor flux to void
	
	# These compartments must have been declared by other modules
	snow_box : compartment("Snow")
	soil     : compartment("Soil")
	aquifer  : compartment("Aquifer")
	river    : compartment("River")
	
	snow_box.distribute(lu)             # Many or all of the computations could still be done only once, instead of per lu, if framework can determine that they are the same.
	soil.distribute(lu)
	aquifer.distribute(subcatch)
	river.distribute(subcatch)              # [river, lake].distribute(subcatch)  (or similar?) if allowing interchanginge of compartments of this type.
	
	#atmosphere.distribute(lu)   # This would allow the user to optionally have separate precip and air_t per lu. Can not do it for subcatch unless soil is distributed per subcatch.
	
	simply_solver : solver("Simply solver", "IncaDascru", 0.1)
	
	soil.water.solve(simply_solver)
	aquifer.water.solve(simply_solver)
	river.water.solve(simply_solver)
	# No solver for snow.water and snow.snow, so these are evaluated as discrete (one per timestep) fluxes.
	
	soil    .hydr    .re_index()        # Re-index this parameter group over (no index sets) so that it does not index over lu. The other soil par_group will index over lu.
	snow_box.snow_par.re_index()     # Can only re_index to a subset of what the compartment is indexed over.
	aquifer .hydr_gw .re_index()
	
	##### Link fluxes between compartments and specify aggregation between compartments that are distributed differently, and unit conversions where volumes are different
	
	par_group("Land cover", lu, subcatch) {
		lu_proportions : par_real("Land use proportions", unit(), 0, 0, 1)
	}
	
	# Aggregation between these compartment are weighted using this parameter (fluxes that are linked below are automatically summed up using this weight)
	aggregation_weight(soil, aquifer, lu_proportions)
	aggregation_weight(soil, surf,    lu_proportions)
	
	# It is unambiguous for the automatic unit system to know how to use catchment_area(km^2) to convert  mm to m^3. May have to do something more complicated for other types of conversions though...
	unit_conversion(soil.water, surf.water, surf.catchment_area)
	unit_conversion(aquifer.water, surf.water, surf.catchment_area)
	
	void    .p_rain     .to(soil.water)
	snow_box.melt_runoff.to(soil.water)
	soil    .quick_flow .to(surf)
	soil    .lat_flow   .to(surf)
	aquifer .gw_flow    .to(surf)
	
	
	
	###### for later
	
	#fjord : compartment_group("Fjord", surf) [ fjord_layer("layer")
	
	lu           : index_set("Landscape units")
	subcatch     : index_set_directed_tree("Sub-catchments",      neighbor("surface flow"))      # The last tag can be used to specify the "neighbor" fluxes.
	fjord_arms   : index_set_graph("Fjord arms",                  neighbor("fjord lateral"))
	fjord_layers : index_set_uniform_1D("Fjord layers", fjord_dz, neighbor("fjord vertical"))
	
	fjord_arms.subset_of(subcatch)
	
	# [a b c] means those types in that order. (*) means any number (maybe find better notation)
	
	
	fjord_arm : [fjord_surf("surf flow") *fjord_water fjord_bottom].distr_unique(fjord_layers, n_layers)
	fjord_arm.distr(fjord_arms)
	fjord_sediment.distr(fjord_arms)
	
	soil.distr(lu, subcatch)
	[*{river lake} fjord_arm].distr(subcatch)
	
	
	lu.distr( soil )
	subcatch.distr( [*{river lake} fjord_arm] )      {a b} means a or b
	
	
	
	flux(river.water, neighbor("surface flow", water), "Reach flow") {
	
	}
	
	#######
}




module("SimplyC", 1,0,0) {
	
	air     : compartment("Atmosphere")
	soil    : compartment("Soil")
	aquifer : compartment("Aquifer")
	surf    : compartment_type("Surface water")
	
	carbon_global :
	soil.par_group("Soil carbon global") {
		base_diss : par_real("Baseline soil DOC dissolution rate", ...)
		kT :        par_real(...)
		kSO4 :      par_real(...)
	}
	soil.par_group("Soil carbon land") {
		base_conc : par_real("Baseline soil DOC concentration", ...)
		compute_min_rate : par_bool(...) {
			true {
				min_rate :  par_real("Soil DOC mineralization rate", unit(day -1), ...)     # Disabled unless compute_min_rate is true.
			}
		}
	}
	# or just have
	# {
	# 	compute_min_rate : par_bool(...)
	#	if compute_min_rate {
	# 		min_rate : par_real(...)
	# 	}
	# }
	# because that allows for disabling or enabling things within other par groups too.
	
	carbon_aquifer :
	aquifer.par_group("Carbon groundwater") {
		gw_doc_type : par_enum("Groundwater DOC conc type", const, .. ) {     # 'const' here refers to the value declared below, making it default.
			const :    "Constant" {
				deep_doc :  par_real("Deep soil DOC concentration", unit(m g, l-1))   # Only enabled if gw_doc_type has value const
			}
			soil_avg : "Soil average"
			mass_bal : "Mass balance" {
				gw_min_hl : par_real("Groundwater DOC half life", ...)                # Only enabled if gw_doc_type has value mass_bal
			}
		}
	}
	
	
	so4_series : series("SO4 deposition", unit(m g, l-1))
	
	so4_dep : property("SO4 deposition")
	air.has(so4_dep) {
		so4_series    if given(so4_series),
		0		      otherwise
	}
	
	temp : property("Temperature", unit(deg_c))
	# We don't declare soil.has(temp), it is delegated to a soil temperature module. Means that this module can't be used unless some other module declares soil.has(temp){ and how to compute it }
	
	
	# Maybe the next two should overwrite the parameter value (like it is possible to do in Mobius 1) instead of having a separate constant property (?)
	# That makes it easier to switch between the two modes without recalibrating.
	use_min_rate : property("Soil DOC mineralization rate", unit(day-1))
	soil.has(use_min_rate) {
		base_diss / base_conc    if compute_min_rate,
		min_rate                 otherwise
	}
	
	use_base_conc : property("Baseline soil DOC concentration", unit(m g, l-1))
	soil.has(use_base_conc) {
		base_conc                if compute_min_rate,
		min_rate * base_diss     otherwise
	}
	
	eq_doc_conc : property("Equilibrium DOC concentration", unit(m g, l-1))
	soil.has(eq_doc_conc) {
		use_base_conc * (1 + kT*soil.temp - kSO4*air.so4)
	}
	
	
	water : substance("Water")
	oc : substance("Organic carbon")
	
	soil.has(water, unit(m m))         # We technically don't have to declare this here since it is done in the hydrology module, but it is good to declare intention (maybe?)
	
	# Not sure if "attached" is best. Can't use "dissolved" since the same system should be used for toxins that are absorbed in carbon or cations that are adsorbed to soil etc. Maybe just use "has" here too, unless it becomes ambiguous?
	soil.water.has_attached(oc, "DOC", unit(k g, k m -2), unit(m g, l-1))    # Second unit (optional) is unit of concentration of oc in water. "DOC" redeclares name of the dissolved type of the substance (optional)
	initial_conc {              # For dissolved substances, one can provide initial concentration instead of initial volume or mass (and framework internally computes the mass).
		eq_doc_conc 
	}
	
	aquifer.water.has_attached(oc, "DOC", unit(k g, k m -2), unit(m g, l-1))
	initial_conc {
		deep_doc                                                                 if  gw_doc_type.const,
		aggregate(conc(soil.water.oc))                                           if  gw_doc_type.soil_avg,
		aggregate(conc(soil.water.oc)) / (tc_g * hl_to_rate(gw_min_hl) + 1)      if  gw_doc_type.mass_bal,
	}
	# 'conc' gives the (automatically computed) concentration of the dissolved substance. 'aggregate' uses the (model-)given aggregations weights. No need to declare a separate cumulation equation like in Mobius1.
	
	surf.water.has_attached(oc, "DOC", unit(k g), unit(m g, l-1))
	initial_conc {
		aggregate(conc(aquifer.water.oc))    # In the particular model this is used in below, aquifer and surf are distributed the same way, so 'aggregate' will be discarded.
	}
	
	flux(void, soil.water.oc, "Dissolution") {
		soil.water * base_diss * (1 + kT*soil.temp - kSO4*air.so4)
	}
	
	flux(soil.water.oc, void, "Mineralization") {
		soil.water.oc * use_min_rate           # Since this equation is unambiguously in the scope of soil.water, it could be ok to just write oc*use_min_rate  here.
	}
	
	flux(aquifer.water.oc, void, "Mineralization") {
		hl_to_rate(gw_min_hl) * aquifer.water.oc       # hl_to_rate  is a function that is either provided by the framework, or maybe you could specify your own functions.
	}
	
	# Override the concentration of DOC in groundwater in some instances (break out of automatic mass balance).
	override_conc(aquifer.water.oc) {                            # Could also provide an override_mass (obviously both can't be used at the same time)
		deep_doc                              if  gw_doc_type.const,
		aggregate(conc(soil.water.oc))        if  gw_doc_type.soil_avg,
		no_override                           if  gw_doc_type.mass_bal,
	}
	
	# Fluxes of dissolved substances between compartments follow the water automatically.
	
	# No need to say anything about what is going on in the river since there are no processes there (yet). It will automatically transport the doc that comes to it.
}



model("SimplyC") {
	add_directory("../../Modules")
	
	# Use all the same modules and couplings of fluxes as in the SimplyQ model above.
	extend_model("simply_q.model", "SimplyQ")
	
	include_module("simply_c.module", "SimplyC")
	
	# All the info about linking fluxes, aggregating and converting is already present in SimplQ, so we don't have to say any more here.
	# For conversion of kg/km2 in soil to kg in river it will attemt to use the same conversion information as was given for the water it is dissolved in, which will succeed in this case.
	# Though for some substance types in more complex it may be necessary to be able to override this info per substance (?)
	
	# Identifiers known in SimplyQ are known here too (?)
	
	soil.carbon_global.re_index()
	aquifer.carbon_aquifer.re_index()
	
	# We should make it automatic that dissolved substances inherit their solver from soil.water unless you want to override it, so the below should be unnecessary
	# soil.water.oc.solve(simply_solver)
	# aquifer.water.oc.solve(simply_solver)
	# surf.water.oc.solve(simply_solver)
	
	soil.water.oc.ignore_flux(soil.water.evap)    # Evapotranspiration should not carry dissolved oc.
}


module("SimplySed") {
"""
Model description.
"""

	top_soil : compartment_type("Top soil")
	
	ar_soil    : compartment("Arable top soil", top_soil)
	nonar_soil : compartment("Non-arable top soil", top_soil)
	
	top_soil.par_group("Erodibility") {
		sed_scale  : par_real("Sediment input scaling factor", ...)
		sed_pow    : par_real("Sediment input nonlinear coefficient", ...)
	}
	
	top_soil.par_group("Erodibility land") {
		sed_reduction : par_real("Reduction of load in sediment")
		c_cover       : par_real("Vegetation cover factor")
	}
	
	top_soil.par_group("Land slope") {
		land_slope : par_real("Mean slope of land")
	}
	
	ar_soil.par_group("Crops") {
		doy_spring : par_int(..., !30, !335)           # ! gives enforced boundary (?)
		doy_autumn : par_int(...)
		prop_spring : par_real("Proportion of spring grown crops", ...)
	}
	
	sed_in           : property("Sediment input coefficient", unit(k g, m 3))
	veg_cover_factor : property("Vegetation cover factor", unit())
	
	# Import C function.
	#dynamic_vegetation_cover : external_c("vegetation_cover.h", "vegetation_cover", double(double, int, int, double, int), unit())
	
	triangle : function(x, mid, width, low) {
		linear_response(x, mid-width/2, mid, low, 1)    if x < mid,
		linear_response(x, mid, mid+width/2, 1, low)    otherwise,
	}
	
	
	# Specific top soil types have different implementations of veg_cover_factor
	
	ar_soil.has(veg_cover_factor) {
		# Example of equation that is difficult to express in this language.. Call an external C function instead.
		#dynamic_vegetation_cover(c_cover, doy_spring, doy_autumn, prop_spring, current_time.day_of_year)
		
		#TODO: Not entirely correct. However this is the gist of it. No need for C linkage?
		doy := current_time.day_of_year;
		risk_period := 60;
		
			   prop_spring  * triangle(doy, doy_spring, risk_period, c_cover)
		  + (1-prop_spring) * triangle(doy, doy_autumn, risk_period, c_cover)
	}
	
	nonar_soil.has(veg_cover_factor) {
		c_cover
	}
	
	top_soil.has(sed_in) {
		1e6 * sed_scale * land_slope * veg_cover_factor * (1 - sed_reduction)
	}
	
	surf : compartment_type("Surface water")
	
	erosion_factor : property("Erosion factor", unit(something))
	surf.has(erosion_factor) {
		flow_from_land := non_neighbor_input(surf.water)    # Neighbor is other surface waters, so this gives total input of water from other sources, i.e. land.
		discard_unit(catchment_area * (flow_from_land / catchment_area) ** sed_pow)
	}
	
	sed : substance("Sediment")
	surf.water.has_attached(sed, unit(k g), unit(m g, l-1), "Suspended sediment")
	
	flux(void, surf.water.sed) {
		aggregate(sed_in) * erosion_factor
	}
}

model("SimplySed") {
	extend_model("simply_q.model", "SimplyQ")
	
	# bla bla bla ....
	
	
	[ar_soil, nonar_soil].distribute(subcatch, lu)      #Necessary to have both subcatch and lu to get a different land_slope for these combinations, but veg_cover_factor will still only be computed per lu.
	
	# Each instance of the compartment can either be an ar_soil or an nonar_soil
	# hmm, it is really just the lu that should determine it, and not the subcatch though...   Maybe we should re-think the semantics for this then...
	# something like [ar_soil, nonar_soil].distribute(lu).distribute(subcatch) for cases when you want the choice only to be determined by the first index set ?

	# re_index some par groups etc...
}


# also, in future may need something like [lake_layer.distribute(layer), river].distribute(subcatch)    Hmmm...
# and in and out-fluxes then have to somehow be directed to the top layer of the lake and so on. Quickly becomes complicated.
#    lake_layer.neighbor(river).locate(0)    ..... # or whatever
# also lake layers are neighbors with one another and also have neighbor fluxes. So this entire system maybe has to be better thought through.
# even with easy-lake there are two lake compartments per lake.
# Maybe the lake is a compartment_group, and then the group specifies how it directs "outer" neighbor fluxes vs "inner" neighbor fluxes.

/*
 #More complex stuff in a Contaminant module
	water       : substance("Water")
	oc          : substance("Organic carbon")
	contaminant : substance("Contaminant")
 
	soil.has(water, unit(m m))
	soil.has(oc,    unit(k g, k m -2), "SOC")
	soil.water.has_attached(oc, unit(m g, l-1), "DOC")
	
	soil.air.has_attached(contaminant, unit(n g, k m -2), unit(n g, m -3))
	soil.water.has_attached(contaminant, unig(n g, k m -2), unit(n g, m -3))
	soil.oc.has_attached(contaminant, unit(n g, k g -1))
	soil.water.oc.has_attached(contaminant, unit(n g, k g -1))                #soil.water.oc.contaminant is then transported with all fluxes from soil.water
	
	temp : property("Temperature", unit(deg_k))
	
	air.has(temp) { #declare how it is computed }
	soil.has(temp) { etc }
	aquifer.has(temp) { etc }
	river.has(temp) { etc }
	surf.has(temp) { etc }
	
	# Parameters tied to a substance.
	contaminant.par_group("Physio-chemistry") {
		log_k_ow_25 : par_real("Log10 octanol-water partitioning coefficient at 25°C", unit(), ...)
		dUow    : par_real("Enthalpy of octanol-water phase transition", ...)
	}
	
	R         : constant("Ideal gas constant", 8.314, unit(J, K-1, mol-1))
	base_temp : constant("Temperature at which physiochemical properties are given", 25, unit(deg_c))
	
	# Declaring a universal equation for the property (not specific to location)
	log_k_ow : property("Log10 octanol-water partitioning coefficient", unit()) {
		temp_k := convert(temp, unit(K));
		base_k := convert(base_temp, unit(K));
		log_k_ow_25 - (1e3*dUow / (ln(10)*R))*(1/temp_k - 1/base_k)
	}
	
	#TODO: This is a property of the compartment AND the contaminant. But soil.contaminant is not a thing since it is always soil.water.contaminant etc.
	# Is it ok to let the framework infer that it should be computed per compartment too, or should it be declared in some way?
	
	# Will use the same equation, but with 'temp' relative to the compartment.
	contaminant.has(log_k_ow)
	
	
	
#In model composition
	contaminant_type : index_set("Contaminant type")
	
	# Can also distribute substances over index sets (many types of substance, with same equations, but parametrized differently)
	contaminant.distribute("Contaminant type")
	
	
	
#Matrix parameters
	# Like in PERSiST or between plastic classes in INCA-MP
	
	# How is the parameter defined?
	#perc : par_matrix("Percolation matrix", ...)  # But how does it determine that 'soil_box' is the "inner" index set that creates the matrix (and not lu). Maybe tie this to the compartment group concept (see above)
	
	neighbor_flux(soil.water, soil.water) {
		min(from.runoff * perc.from.to, to.mpi)       # perc.from.to is the percolation value
	}


# Python wrapper.
	#Since the symbols of all the variables are exposed to the interface, we can instead of having to write
	# dataset.set_parameter_double("Baseflow index", ["Forest"], 0.5)   and   series = dataset.get_result_series("Reach flow", ["Coull"])
	# instead implement __setattr__ and __getattribute__ to allow syntax like the following in the python wrapper:
	dataset.soil["Forest"].bfi = 0.5
	dataset.run_model()
	flow_series = dataset.river["Coull"].flow

	# we could actually do something similar with __setitem__ and __getitem__ currently to achieve the following:
	dataset.parameter["Baseflow index"]["Forest"] = 0.5
	flow_series = dataset.result["Reach flow"]["Coull"]
 */





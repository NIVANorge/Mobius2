


	Dependency system for connection aggregations is very error prone. Esp. wrt. 'top' and 'bottom'.
		Ideally the entire system should be re-thought.

	Finish NIVAFjord!!
		horizontal fluxes.

	The "loose depends" system is kind of iffy.
		I think there are no guarantee that something is not placed in a for loop too late initially. Esp. bc of how create_batches works.
			This in particular may have been fixed now.
	
	Use get_symbol a few places where it could be needed.
	
	Finish connection system
	
		Finish the simple hydraulics model.
		
		graph and directed_tree
			Must specify 'nowhere' in the regex for it to be an allowed target
			
			Could have the graph types be singly_directed and multiply_directed (?). No specific need for what we now call a tree to not have cycles.
		
		The above requires finishing the entire regex thing.
		
		graph connections
			More stress testing
				Attaching data to edges
					How does this work when edge indexes are not saved in the data set (data set code should maybe itself do the edge index generation (?))
			
			Check that the edge index set is OK (i.e. sub-indexed to the right thing).
			Allow naming edges (?)
			Make sure edge indexes are not saved to data set, but still make it work with parameter saving.
			
			Should not put restriction condition on graph flux, since it won't be evaluated any way if there are no edges.
			
			For [below] accesses in flux, we probably need to pre-process them to check that the units are the same in all instances etc.

		all_to_all, grid1d:
			
			Maybe signal that something can be a matrix parameter by having a double dependency on that compartment in the par group?

		What about:
			accessing
				something[above]    ( or below )
			should not invalidate the entire function, only make the something[above] itself evaluate to 0 (?)
				Or maybe invalidate ( set to 0 ) just that particular expression ( though that is not as well defined ).
			Does this give the correct result in all instances ?
				Would prefer to have this since it improves usability.
				Could also allow manual checking of validity to circumvent edge cases, but maybe prefer not to.
				
		Specific target:
			Properly process the @specific function tree, incl. flags
			Check valid dependencies for the tree.
				Have to think about what types of variables it is allowed to reference.
			Tridiagonal distribution.
			Clamp the index within allowed bounds or zero out the flux if the index is out of bounds (?).
				This is actually the only feature currently where a user error could lead to unsafe memory accesses. Unless we add the constraints.
		
		Dissolved fluxes -
			make dissolvedes of negatives work for other types (all_to_all, graph (maybe) regular fluxes (maybe), but probably not directed tree).
			
			
				
	Consider renaming 'nowhere' to 'out' (both connection data and regular fluxes)
	
	*** Intermediate-pri ***
	
		Some system for specifying state variables that should not be stored (properties only).
			Quite complicated. In practice, need a separate storage for them that is only 1 deep. Also must disallow last() on them etc.
			First iteration could be to just not display them, but still have them stored in the same place as everything else
		
		Consider just adding connection fluxes to derivatives as they are computed instead of having so many aggregates (except when these are actually needed, which would be much less often).
			This would be a major change, but could create some speedup.
			Alternatively, have them be non-stored as a default. (Requires less drastic changes, but has almost the same benefits of less memory usage).
		
		Make an (optional) validator that validates the order of instructions in the final structure according to (various types of) dependencies!
			Useful for catching errors, which we some times have but are slow to detect.
		
		override {}  declaration.
			E.g. to change the connection regex of a connection in an extending model.
			How to do it for no_carry?
				The way we now do no_carry is in general maybe not that good after all.
				May eventually need to specify no_carry outside the module the flux was already declared in, but let's wait and see.

		Clean up the Vansj√∏ input data (merge sheets). Maybe re-download some of it.
	
		Clean up the prune_tree system.
			Could get rid of using Function_Scope in prune_helper?
				Tried it, but it has a bug.
			Easy to have leaks when moving and deleting nodes the way it is done now.

		Normalized file paths can be different depending on how they were loaded using relative paths. This causes it some times to try to load the same library twice, which causes a name clash.
			Need a fully standardized normalized path (?)

		It could probably be better if you *only* declare the time unit for the flux
			Alternatively need some way to construct units, like
				combine_unit(soil.water.oc.tox, [day-1])
			This has to do with module reusability, could apply the module to quantities with different units.
				

		More on module loading and the declaration format:
			
			The 'extend' system is just not that good. Will be problems when you want to override something in the earlier model,
			or if two extended models load the same module (not a problem before, but will be if we allow multiple loads of the same module, which can then cause unintended duplicates)
				With inlined modules 'seeing' their parent scope it is not that nice that extend_model puts a lot of stuff into that scope.
				+ other reasons like overriding earlier declarations being difficult.
				
			Dynamic module choice (based on data set)
				
			Whether or not something is formatted as a var_location could be checked already in the match_declaration stage (e.g. Not just pass it as Token_Type::identifier).
			
			For properties, maybe always just put the unit on the property (but not on quantities obviously).
			
			Make it easier to load a sub-model of a larger model with a data set that was declared for the larger model.
				Needs for instance to handle additional input series that are indexed over index sets that don't appear in the sub-model.
		
			Check for conflicting declarations of variables (unit, name).
			
			To fix some issues, we should probably scan a decl body for declarations, *then* process them. E.g. to make sure inline decls are also processed out of order.
			This could also allow us to have static if expressions. Would just have to resolve outer consts and parameters first, but that should be ok.
				(see more in doodle)
				
		
		The system of automatic solvers unnecessarily puts soil TDP on a solver in SimplyP. Should be a way to specify it not to. Or maybe even for it to detect that it is not necessary.
			Actually, this should be detected. It should be omitted because the value is an override, and none of the dependencies are on solvers. Instead of having auto-solver with an override, let the solver propagate as for properties.
			
		More cleanup of State_Var system
			the way we handle regular_aggregates of fluxes is not necessarily that nice.
			organize unit_conversion_tree differently.
				and clean up how it is applied.
		Maybe have a separate lookup structure for fluxes and have the common flux things stored there.
			(in many cases we just loop over all fluxes and try to find common things for them)
			loc1, loc2, unit_conv, connection, etc.
				
		Let '/' always be a real division, and maybe have a separate operator // (or similar) to force integer division.
		
		Finish sub-indexed index sets
			May need to zero out fluxes across (as in connections) the super index set if they also index over the sub index set. (mostly relevant for all_to_all, grid1d (and graph)).
			Sub-indexed series data.
			
			Make MobiView2 display if a selected series was not computed.
			
		Go over and improve diagnostics in error messages (all over the place).
		
		
	*** Low-pri ****
	
		Make the data_set declarations match the model declarations better, e.g. version() in module decls.
			Just let the data_set use the same AST, where a [] block parses as "data", which is just a token list.
			Should be able to make registries match up better to simplify some things when loading into the Model_Application.
			
			Could have a serialization name for entities in the data set and use that to map them over to the model? Then use Entity_Id inside the data_set, but just map these to the model entity_ids.
		
	
		Is there any way we could simplify 'aggregation_weight' and 'unit_conversion' so that they don't have to be declared like that?
		
		Maybe the decl_type of module template should just be module_template (in the module files).
		
		It can sometimes be very difficult to debug what is going on when one forgets to put a quantity on a solver and this inadvertently doesn't give an error.
		
		Capping of discrete fluxes from override variables not necessary?
			I.e. don't have to check if a flux with the source in a variable that is 'override' overtaxes its source.
		
		
		Separate var storage that is not temporal
			Current override system of inputs on properties is not the best. Should be possible on a per-index basis (but that requires something like input_was_provided in Mobius1)
			Similarly also want to allow inputs to override parameters.
		
			Check for constant computability of properties (or constant series or constant state vars) and have them stored in a separate structure that is computed at model startup.
			Must also handle if there is a constant .override
				Can use the same storage as for variables that are not stored temporally.
		
		Just make the global module in the data set be a module scope in the data set. Simplifies things a bit. Maybe a module {} without a name (?)
		
		In all_to_all and grid1d connection data in the data set, it should be sufficient to just provide the name of the index set.
		
		MobiView:
		
			Plot
				stacked_share has a slow implementation.
					Should maybe not sum over all the values each time it is extracted, just do it once and store it.
				Grid line offsets are sometimes strange when you switch to Profile2D then back to regular.
				Normalized axis is weird when all of a series' values are 0.
				Flickering axis labels when scrolling.
				
				"Network" plot for connections. Draw the network along with amount (of some quantity(ies)) as bar plot per node. Animate over time.
					Maybe not just for connection, but for any graph of that quantity?
			
			Sensitivity & optimization - new features
				Combine simple sensitivity into the advanced sensitivity setup.
					Compute statistics of the target stat like variance etc.
					Allow for 2 parameters, with a surf plot eventually.
				GLUE-like sampling?
				Serialize sensitivity setups using a Mobius format instead of json so that we can load the same setups in mobipy eventually.
				More customizable target functions.
				Targets computed from aggregate series (stats of aggregate series).
				
				Optimizer callback doesn't update additional plot view.
			
			Finish all missing functionality from MobiView1
				Index set editing (Will now include connection editing).
				Finish graph views.
								
			tweaks to the state var tree organization
				The icons in "by quantity" view are currently not that intuitive.
				Maybe order direct properties and fluxes above dissolved substances (or have it as an option)
				Allow order by flux? By module?
				
			How to do unit of sum of reach flow if the reach flow unit is in m3/s and the sum is over days?
				Could have both aggregation none and days, and in the later case it also aggregates m3/s -> m3/day .
					A bit annoying do it from a coding perspective though because you have to work with declared units, not standardized units.
			
			More aggregation intervals
				minute, hour, day. (esp. day).
				
			Trend line doesn't make sense for some aggregations.
			Make the residual trend one of the available residual statistics (in terms of optim. it should be minimized in absolute value).
		
		More mobipy functionality.
		
		Some kind of system for specifying assertion checks on user provided data, such as
			lu_prop should sum to 1 over landscape units.
		
		boundary conditions for other types of connections (not grid1d)
			For instance, what happens to the flux in a directed tree if it doesn't have a valid target, is it still computed (yes in some cases, maybe no in others)
			similar for graph when that exists.
		In grid1d, could have wrap-around boundary (?), or could have special values for the boundary (maybe even dynamic)
	
	
		Make it possible to free file memory before a model is deleted.
			Requires ASTs to copy some string data, which is a bit annoying since right now they store Tokens directly.
		
		
		Set units of regular aggregation state variables so that they display correctly if viewed.
			note that it is a bit tricky for fluxes.
			
			
		aggregate() of series and parameters, or even of arbitrary expressions.
			Would need a separate instruction type for it.
			For parameters, ideally it should just be computed once using the constant system described above.
			For arbitrary expressions, it could be tricky to figure out what compartment it actually aggregates from.
		
		
		Aggregation variables are not always necessary if we could just add things to derivatives directly, but this is not the case always.
			Would require a big systemic change to model_compilation and model_codegen to implement this.
		
		Make discrete fluxes work like other fluxes for aggregation stuff so that everything works the same way for them (including some connection stuff).
			Reimplement discrete fluxes for connections in some situations.
			This may not go well with the above suggested change though.
		
		
		Would like to get the assembly code for the model, but it is apparently notrivial. Can get the obj by using a dummy object cache that dumps the memory
			https://github.com/llvm/llvm-project/blob/main/llvm/examples/OrcV2Examples/LLJITWithObjectCache/LLJITWithObjectCache.cpp
			One could then manually disassemble it.
			
		Imperative constructs for the function scope.
		
		Other solver algorithms.
		
		Different Var_Restrictions resulting in the same condition on the index, and causing multiple checks of the same condition (in model_codegen).
		
		Declaring units with a handle and reusing that handle does not quite work, at least not for parameters.
		
		last(something) doesn't automatically cause it to have an initial value computation (if one was not set).
		
		Error if you access time.fractional_step outside a solver?

		Re-consolidate input loading with the serialization system (In terms of how it looks up ids of names).
			Tricky...

	Probably not ?:
	
		If a dissolved substance can flow somewhere, you don't have to declare that it is there (?)
			Maybe only if you specify it to disperse.
			could be tricky wrt units.
			could be tricky since right now we assume all quantities are declared.
			how to determine initial value?
			sometimes you don't want it there (though that could be accomplished with no_carry)
	
		Selecting profile or profile2d should select all the indexes if only one index set is active and only one index is selected.
			Maybe not desirable
	
	
	
	NOTES
		
	Hope for reply on one of these 
		https://discourse.llvm.org/t/how-to-generate-ir-so-that-the-loop-vectorizer-can-vectorize-it/69096/2
		https://stackoverflow.com/questions/75674759/llvm-loop-vectorizer-does-not-vectorize-my-ir?noredirect=1#comment133504571_75674759
		
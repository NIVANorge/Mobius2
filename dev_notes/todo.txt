
	Finish sub-indexed index sets
		May need to invalidate more fluxes across the super index set.
		Sub-indexed series data.

	Finish connection system
		
		better checks for what fluxes can be put on what connections ..   ---- is this still relevant??
		
		it is a bit overzealous to require specification of a regex for all_to_all and grid1d connections (maybe just require the identifier symbol, not the operator).
		Finish regex checks.
		
		arbitrary target(conn, val) declarations for use in non-fluxes (only valid for grid1d (?))
			quite a bit of work though... But should be worth it.
			also source(conn, val) or source(val) (for grid1d at least, and later graph) for looking up the value of the previous thing.
			Consider using 'above' and 'below' instead (?)
			
		boundary conditions
			goes for most of the types. For instance, what happens to the flux in a directed tree if it doesn't have a valid target, is it still computed (yes in some cases, maybe no in others)
			In grid1d, could have wrap-arounds, or could have special values for the boundary (maybe even dynamic)
				similar for graph when that exists.
			
		graph connections
			Figure out how to use sub-indexing for indexing outgoing connections (need to generate index sets (ouch)).
	
	Make sure only the right kind of Model_Instructions can be matrix indexed (maybe allow for properties, but not for most fluxes and quantities, except for all_to_all fluxes (and only with the right index set)).
		Also only one matrix indexing for a given state variable (at least for now)
		The challenge is providing good error messages.
	ability to correctly view all_to_all fluxes (or other matrix results) in MobiView.
	
	Do proper memory management for Math_Expr_FT. The current system is becoming unbearable, and quickly leads to leaks or double deletes.
		Seriously!
	
	*** Intermediate-pri ***

		Units
			Allow units to have the form [30 month] (i.e. the leading number instead of si prefix)
			Allow rational coefficients and powers in units.
			Write unit back to file (only needed for time step units for now).
		The actual unit checking system
			Simple part - generate units and scalings for concentrations and fluxes.
			More complicated part - check the units of everything.
			

		Processes not specified per compartment / quantity. Can be attached to those.
			- something like compartment_type etc.
			- have to figure out what to do with duplicates of par_group etc. - ties into name system (next item).
		
		Better scoping system for declaration names (not just for symbols).
			also for variable names.
		
		Allow redeclaration of constants without conflict (?)

		Move to std::string instead of String_View in path_utils.. (if possible, had a problem when trying it before).
		
		Allow declaration of no_carry inside modules.
		
		Organize state var tree by quantity in MobiView (as an option).
			Maybe order direct properties and fluxes above dissolved substances (or have it as an option)
		
		Check for conflicting declarations of variables (unit, name).
		
		New system of automatic solvers unnecessarily puts soil TDP on a solver in SimplyP. Should be a way to specify it not to. Or maybe even for it to detect that it is not necessary.
			Actually, this should be detected. It should be omitted because the value is an override, and none of the dependencies are on solvers. Instead of having auto-solver with an override, let the solver propagate as for properties.
			
		More cleanup of State_Var system
			the way we handle regular_aggregates of fluxes is not necessarily that nice.
			organize unit_conversion_tree differently.
				and clean up how it is applied.
		Maybe have a separate lookup structure for fluxes and have the common flux things stored there.
			(in many cases we just loop over all fluxes and try to find common things for them)
			loc1, loc2, unit_conv, connection, etc.
	
	
	*** Low-pri ****
	
		Rules for using 'target' is very unintuitive, and implementation is not clean.
		unit conversions also applied to connection graph arrows.
		should the connection be scoped to a module in the data set file if it doesn't exist in the model scope in the model?
			
		Override declarations.   --- not needed for connections since we found another way. Also, not certain what is the best way to do it.
			No known important use case at the moment.
	
		Check for constant computability of properties (or constant series or constant state vars) and have them stored in a separate structure that is computed at model startup.
			Not high priority, just a nice feature.
			
		If a dissolved substance can flow somewhere, you don't have to declare that it is there (?)
			could be tricky wrt units.
			could be tricky since right now we assume all quantities are declared.
			sometimes you don't want it there (though that could be accomplished with no_carry)
		
		Let declarations in inlined modules be visible in the parent model scope (?) or other way around is maybe more reasonable.
			May not be wanted.
		
		Iterating over state variables should skip invalid ones automatically.
		
		In all_to_all and grid1d connection data, it should be sufficient to just provide the name of the index set.
		
		MobiView, stacked_share vs. negative values.
		
		
	*****************   DONE:   ***********************
	
	Sub-indexing (most of it)
		Data set formatting, read/write, interaction with Model_Application
			a bit annoying for parameter format, and also indexing of other things within the data set.
		Needs to have index_counts as lookup data for model code.
		Need to revamp how to look up things from storage.
			Easier to keep storage sized to the max number of indexes even though it is a bit wasteful. Could always be improved later.
	
	Interchangable components for connections. Simple system.
		lake vs. river
	
	multiple connections per variable
	
	'target' value fetching inside flux body (only for all-to-all and grid1d connection fluxes so far).
	integer indexed index sets.
	grid1d connection.
	
	**component declarations in the data set should be local to the connection data. Otherwise it makes things annoying.
			also, component data is not properly set up unless there is an arrow (which could more easily be fixed if we do it like this)
	
	connection fluxes of dissolvedes seem to add to the base substance rather than the dissolved substance.
	**aggregation weights applied to graph arrows !!
	
	something is broken with fluxes from discrete variables to connections (should just be flat out disallowed for now, but for some reason isn't)
	
	Make and test a SimplyTox    (partial at least)
	
	Index set distribution of quantities
		+ par groups on quantities
		
	Probably only allow connection fluxes between state variables that are on solvers. (Currently set to be the default)
		
	Relative paths are always relative to the model source file, but this breaks when you do extend_model of a model from another folder.
	Same when including a library from another library...
	
	Make variables of type Source_Location be named source_loc consistently to not confuse with other things.
	
	Allow fluxes to have a default no_carry()
	
	Make it automatic that certain state variables are on solvers (dissolveds)
	
	Allow multiple has declarations for the same variable (or fix existing system).
	
	Matrix formatting of parameters in the data file.
	
	Other types of connections
		all_to_all
	all_to_all connections for quantities (not just compartments)
	the index set(s) the connection is over should be taken from the data set.
		compartments of multiple index sets
		
	Clean up the State_Variable struct to make it less easy to have usage errors.
	
	check what parts of the connection are actually used (not just based on arrows in the data set, but also on what fluxes are put along the arrows).
		e.g. what variables can actually be a target - only generate code for those etc.
		
	No error for unlabeled code block for quantity !?
	
	New format for units.
	
	String_View auto-converting to bool also means that it auto-converts to int. This can cause bugs when we refactor some things.
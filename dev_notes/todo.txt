

	Make NIVAFjord!!

	

	Clean up how we generate code for computing indexes. It is very messy.

	The "loose depends" system is kind of iffy.
		I think there are no guarantee that something is not placed in a for loop too late initially. Esp. bc of how create_batches works.
			This in particular may have been fixed now.
	

	Finish connection system

		Dissolved fluxes -
			make dissolvedes of negatives work for other types (all_to_all, regular fluxes (maybe)).
			
		graph connections
			Figure out how to use sub-indexing for indexing outgoing connections (need to generate index sets (ouch)).

		all_to_all:
			Maybe signal that something can be a matrix parameter by having a double dependency on that compartment in the par group?

		What about:
			accessing
				something[above]
			should not invalidate the entire function, only make the something[above] itself evaluate to 0 (?)
				Or maybe invalidate ( set to 0 ) just that particular expression ( though that is not as well defined ).
		Does this give the correct result in all instances ?
			Would prefer to have this since it improves usability.
			Could also allow manual checking of validity to circumvent edge cases, but maybe prefer not to.

	
	*** Intermediate-pri ***
		
		Override declaration.
			E.g. to change the connection regex of a connection in an extending model.
			How to do it for no_carry?
				The way we now do no_carry is in general maybe not that good after all.
	
	
		Clean up the VansjÃ¸ input data (merge sheets). Maybe re-download some of it.
	
		Consider just adding connection fluxes to derivatives as they are computed instead of having so many aggregates (except when these are actually needed, which would be much less often).
			This would be a major change.
	
		Clean up the prune_tree system.
			Could get rid of using Function_Scope in prune_helper?
				Tried it, but it has a bug.
			Memory management is easy to get wrong in this system.
	
		Some system for specifying state variables that should not be stored (properties only).
			Quite complicated. In practice, need a separate storage for them that is only 1 deep. Also must disallow last() on them etc.
			First iteration could be to just not display them, but still have them stored in the same place as everything else

		Normalized file paths can be different depending on how they were loaded using relative paths. This causes it some times to try to load the same library twice, which causes a name clash.
			Need a fully standardized normalized path (?)

		It could probably be better if you *only* declare the time unit for the flux
			Alternatively need some way to construct units, like
				combine_unit(soil.water.oc.tox, [day-1])
			This has to do with module reusability, could apply the module to quantities with different units.
				

		More on module loading and the declaration format:
			
			The 'extend' system is just not that good. Will be problems when you want to override something in the earlier model,
			or if two extended models load the same module (not a problem before, but will be if we allow multiple loads of the same module, which can then cause unintended duplicates)
				With inlined modules 'seeing' their parent scope it is not that nice that extend_model puts a lot of stuff into that scope.
				+ other reasons like overriding earlier declarations being difficult.
				
			Dynamic module choice (based on data set)
				
			Whether or not something is formatted as a var_location could be checked already in the match_declaration stage (e.g. Not just pass it as Token_Type::identifier).
			
			For properties, maybe always just put the unit on the property (but not on quantities obviously).
			
			Make it easier to load a sub-model of a larger model with a data set that was declared for the larger model.
				Needs for instance to handle additional input series that are indexed over index sets that don't appear in the sub-model.
		
			Check for conflicting declarations of variables (unit, name).
			
			Inline decls in arguments don't quite work unless they are in the right order. May need to recursively make a list of all decls in a decl body, then process that list. A bit tricky though.
		
		
		The system of automatic solvers unnecessarily puts soil TDP on a solver in SimplyP. Should be a way to specify it not to. Or maybe even for it to detect that it is not necessary.
			Actually, this should be detected. It should be omitted because the value is an override, and none of the dependencies are on solvers. Instead of having auto-solver with an override, let the solver propagate as for properties.
			
		More cleanup of State_Var system
			the way we handle regular_aggregates of fluxes is not necessarily that nice.
			organize unit_conversion_tree differently.
				and clean up how it is applied.
		Maybe have a separate lookup structure for fluxes and have the common flux things stored there.
			(in many cases we just loop over all fluxes and try to find common things for them)
			loc1, loc2, unit_conv, connection, etc.
				
		Let / always be a real division, and maybe have a separate operator // (or similar) to force integer division.
		
		Re-consolidate input loading with the serialization system.
			Tricky...
		
		Finish sub-indexed index sets
			May need to zero out fluxes across (as in connections) the super index set if they also index over the sub index set. (mostly relevant for all_to_all, grid1d (and graph)).
			Sub-indexed series data.
			
		Go over and improve diagnostics in error messages (all over the place).
		
		Make mobipy work again (and better).
		
	*** Low-pri ****
	
		Is there any way we could simplify 'aggregation_weight' and 'unit_conversion' so that they don't have to be declared like that?
			Could at least infer unit conversion for dissolvedes if their conc units are compatible.
		
		Maybe the decl_type of module template should just be module_template (in the module files).
		
		It can sometimes be very difficult to debug what is going on when one forgets to put a quantity on a solver and this inadvertently doesn't give an error.
		
		Capping of discrete fluxes from override variables not necessary?
			I.e. don't have to check if a flux with the source in a variable that is 'override' overtaxes its source.
		
		
		Separate var storage that is not temporal
			Current override system of inputs on properties is not the best. Should be possible on a per-index basis (but that requires something like input_was_provided in Mobius1)
			Similarly also want to allow inputs to override parameters.
		
			Check for constant computability of properties (or constant series or constant state vars) and have them stored in a separate structure that is computed at model startup.
			Must also handle if there is a constant .override
				Can use the same storage as for variables that are not stored temporally.
		
		Just make the global module in the data set be a module scope in the data set. Simplifies things a bit. Maybe a module {} without a name (?)
		
		In all_to_all and grid1d connection data in the data set, it should be sufficient to just provide the name of the index set.
		
		MobiView:
		
			stacked_share has a slow implementation.
				Should maybe not sum over all the values each time it is extracted, just do it once and store it.
			
			Sensitivity & optimization - new features
				Combine simple sensitivity into the advanced sensitivity setup.
					Compute statistics of the target stat like variance etc.
					Allow for 2 parameters, with a surf plot eventually.
				GLUE-like sampling?
				Serialize sensitivity setups using a Mobius format instead of json so that we can load the same setups in mobipy eventually.
				More customizable target functions.
				Targets computed from aggregate series (stats of aggregate series).
				
				Optimizer callback doesn't update additional plot view.
			
			Finish all missing functionality from MobiView1
				Index set editing (Will now include connection editing).
								
			tweaks to the state var tree organization
				The icons in "by quantity" view are currently not that intuitive.
				Maybe order direct properties and fluxes above dissolved substances (or have it as an option)
				Allow order by flux? By module?
				
			How to do unit of sum of reach flow if the reach flow unit is in m3/s and the sum is over days?
				Could have both aggregation none and days, and in the later case it also aggregates m3/s -> m3/day .
					A bit annoying do it from a coding perspective though because you have to work with declared units, not standardized units.
			
			More aggregation intervals
				minute, hour, day. (esp. day).
				
			Trend line doesn't make sense for some aggregations.
				
		
		Some kind of system for specifying assertion checks on user provided data, such as
			lu_prop should sum to 1 over landscape units.
		
		boundary conditions for other types of connections (not grid1d)
			For instance, what happens to the flux in a directed tree if it doesn't have a valid target, is it still computed (yes in some cases, maybe no in others)
			similar for graph when that exists.
		In grid1d, could have wrap-around boundary (?), or could have special values for the boundary (maybe even dynamic)
	
		
		Set units of regular aggregation state variables so that they display correctly if viewed.
			note that it is a bit tricky for fluxes.
			
			
		aggregate() of series and parameters, or even of arbitrary expressions.
			Would need a separate instruction type for it.
			For parameters, ideally it should just be computed once using the constant system described above.
			For arbitrary expressions, it could be tricky to figure out what compartment it actually aggregates from.
		
		
		Aggregation variables are not always necessary if we could just add things to derivatives directly, but this is not the case always.
			Would require a big systemic change to model_compilation and model_codegen to implement this.
		
		Make discrete fluxes work like other fluxes for aggregation stuff so that everything works the same way for them (including some connection stuff).
			Reimplement discrete fluxes for connections in some situations.
			This may not go well with the above suggested change though.
		
		
		Would like to get the assembly code for the model, but it is apparently notrivial. Can get the obj by using a dummy object cache that dumps the memory
			https://github.com/llvm/llvm-project/blob/main/llvm/examples/OrcV2Examples/LLJITWithObjectCache/LLJITWithObjectCache.cpp
			One could then manually disassemble it.
		
		Connection Regexes
			it is a bit overzealous to require specification of a regex for all_to_all and grid1d connections (maybe just require the identifier symbol, not the operator).
			Finish regex checks or scrap them altogether.
		
		Other solver algorithms.
		
		May eventually need to specify no_carry outside the module the flux was already declared in, but let's wait and see.
		
		Codegen for the NIVAFjord model generates
			state_var[iter_547 + 2764] <- state_var[3012 + iter_547] * exp(-state_var[879] * dz[8]) * A[24 + iter_547] / A[iter_547 + 23] if iter_547 + 1 < 124 & iter_547 + 1 < 124,
			0 otherwise
		It should have recognized that it is not necessary with the duplication of the condition.
			Probably due to different Var_Restrictions resulting in the same condition on the index.
		
		Declaring units with a handle and reusing that handle does not quite work, at least not for parameters.
		
		

	Probably not ?:
	
		If a dissolved substance can flow somewhere, you don't have to declare that it is there (?)
			Maybe only if you specify it to disperse.
			could be tricky wrt units.
			could be tricky since right now we assume all quantities are declared.
			how to determine initial value?
			sometimes you don't want it there (though that could be accomplished with no_carry)
	
		Selecting profile or profile2d should select all the indexes if only one index set is active and only one index is selected.
			Maybe not desirable
	
	
	
	NOTES
		
	Hope for reply on one of these 
		https://discourse.llvm.org/t/how-to-generate-ir-so-that-the-loop-vectorizer-can-vectorize-it/69096/2
		https://stackoverflow.com/questions/75674759/llvm-loop-vectorizer-does-not-vectorize-my-ir?noredirect=1#comment133504571_75674759
		


	*** High pri ***
	
		MobiView2: When selecting the boundary basin temperature, it doesn't properly restrict the size of the layer index to the boundary size.
			Also, indexes that appear to be selected are not.
		
		Why do file saving errors crash the program instead of getting caught now?
		
		Entities used by function bodies of overridden properties are not accounted for.
			We should really process the function trees of variables that are overridden also to avoid this (and detect other errors that may be hidden by this.).
		
		Finish @exclude system for extend().     extend("simplyq_model.txt") @exclude(solver(), heat : quantity)
			The only thing that is a bit iffy is how to handle conflicting excludes of loads of the same model. Merge the excludes, I guess?
			Also, doesn't work well with inlined declarations (which is another reason why we should rework those).
		

		Specific models
			NIVAFjord!!
				Fix the processed input series
				Fix mass balanced of dissolved (negative tracer! - is something missing a @bidirectional, or is it wrong for the horizontal exchange?)
			
			EasyChem!!
			
			Finish the simple hydraulics model.
			
		Finish connection system
		
			Properly test the flux restriction refactoring.
				Probably broken if we have grid1d of the same connection in both source and target.
			
			Dependency system for connection aggregations is very error prone and complicated. Esp. wrt. 'top' and 'bottom'.
				(in terms of how it is computed, not in terms of user-facing functionality)
				Ideally the entire system should be re-thought or restructured.
		
			in_flux(connection, something) will some times depend on the indexes being ordered in the same way as in the connection graph.
				Happens if a flux along the connection (in)directly depends on the in_flux(connection, something).
				This is not solvable without remapping the indexes (or asking the user to reorder them).
				Could detect if this happens and give an error, but that alone is a bit of work.
					We should only allow it if no_cycles is specified.
					If no_cycles is specified, we should demand that the indexes in the data set are in the order of appearance.
		
			Component index sets should probably be declared in the connection declaration in the model (also for directed_graph). It is too integral to how to model works to leave it to data set.
			
			Have to figure out what something like
				flux(blabla, something[vert.below], ...)				
			means. Right now the location 'something' is not used, and we only need to declare it to allow [.top] or [.specific] etc.
				Need this for NIVAFjord
			Maybe just make the syntax
					flux(blabla, target[vert.below])
			and disallow having specific location there (except for grid1d). And this is what we do for all 'below' connection targets.
				Could later extend it to have different code depending on the target (for graph and directed_tree).
		
			graph connections
				
				One should need to explicitly allow isolated nodes using something like    a | (....)
				
				For [below] accesses in flux, we probably need to pre-process them to check that the units are the same in all instances etc. and that "indexing below" is correct.
					Alternatively do unit conversions, but how?
					May have to be done inside resolve_function_tree, so we need to access the connection data there.
					
				Finish regex check in the general case
				
				Make it work with quantities.
					And allow aggregation weight for them (can for instance be used for degradation chains where some of the mass goes away).

			grid1d:	
				Maybe the .specific code AST should be tied to the var loc instead of the variable, like bling[vert.specific{ ..code }]
					Could then also allow .specific inside main code.
					
			Specific target:
				Properly process the @specific function tree, incl. flags
				Check valid dependencies for the tree.
					Have to think about what types of variables it is allowed to reference.
				Clamp the index within allowed bounds or zero out the flux if the index is out of bounds (?).
					This is actually the only feature (except external_computation) currently where a user error could lead to unsafe memory accesses. Unless we add the constraints.
					
				Tridiagonal distribution.
			
		Bidirectional
			Should check that target unit is the same a source unit always.
				And maybe not with aggregation weights.
		
			Have an optional test to see if non-bidirectional fluxes were negative after or during a run.
		
			Make bidirectional work for regular fluxes (maybe).
				Though probably not for aggregates.
			
			Better tests for bidirectional fluxes before codegen. (That is, check that the concentration exists in the target). If it doesn't could maybe just have a warning, but then the conc in the target would have to be treated as 0.
			
			
	
	
	*** Intermediate-pri ***
		
		Allow averaging input values that are assigned to the same time step (makes it easier to work with different step sizes.)
		
		What to do with discrete fluxes with varying step sizes.
			They are currently not step size independent. Should they be re-scaled somehow if the step size is different from the one that is declared in the flux?
			
			What to do about things like (computed) global radiation that should really have an hourly variation with low step sizes but should be averaged with higher?
			
			
	
		Saving data_set docstring newline increase.
		
		Warning on HUGE allocations.
		
		Union index sets
			say     a : index_set("A") @union(b, c)
			We probably have to disallow dependency on a if you have dependency on both b and c, or it is ambiguous.
				Already fixed for direct dependencies (parameters, index sets)
				On what level do we check this? Must be during the resolution loop?
			A Var_Location hould not be able to both depend on a union and a member of that union
				This is currently checked per component basis, but not combined. Should be done in model_composition
			When doing checks with std::set<Entity_Id> for index sets, we could instead use a bitfield over the id... (Efficiency)
	
		Some system for specifying state variables that should not be stored (except temporarily).
			Need a separate storage for them that is only 1 deep. Also must disallow last() on them etc.
				
			MobiView2:
				First iteration could be to just not display them.
				If it is constant, could then display in the stat window, just not in the plot, or even make a constant plot for it.
			
			Could determine if a variable is going to be constant and then just compute it on the initial step constant @override
				Can use the same storage as for variables that are not stored temporally.
				
			Make this the default for many aggregation variables (but maybe need to allow configuring them to be stored).
			
		Also a system for specifying different display variants (along with the code in MobiView2 to make use of that, which is the work intensive part).
			E.g. say if a variable should not be displayed in MobiView2 (but have a display all checkbox button that re-enable them)
		
		Consider just adding connection fluxes to derivatives as they are computed instead of having so many aggregates (except when these are actually needed, which would be much less often).
			This would be a major change, but could create some speedup.
			Alternatively, have them be non-stored as a default. (Requires less drastic changes, but has almost the same benefits of less memory usage - though still more computations).
		
		
		Make an (optional - developer mode) validator that validates the order of instructions in the final structure according to (various types of) dependencies!
			Useful for catching errors, which we some times have but are slow to detect.

		Clean up the Vansj√∏ input data (merge sheets). Maybe re-download some of it.
	
		Clean up the prune_tree system.
			Could get rid of using Function_Scope in prune_helper?
				Tried it, but it has a bug.
			Easy to have leaks when moving and deleting nodes the way it is done now.

		Normalized file paths can be different depending on how they were loaded using relative paths. This causes it some times to try to load the same library twice, which causes a name clash.
			Need a fully standardized normalized path.

		It could probably be better if you *only* declare the time unit for the flux
			Alternatively need some way to construct units, like
				combine_unit(soil.water.oc.tox, [day-1])
				[day-1]@mul(soil.water.oc.tox)
			This has to do with module reusability, could apply the module to quantities with different units.
				
		error_print_location
			Make it print the bracket if needed.

		More on module loading and the declaration format:
				
			Dynamic module choice (based on data set)
			
			For properties, maybe always just put the unit on the property (but not on quantities obviously).
			
			Make it easier to load a sub-model of a larger model with a data set that was declared for the larger model.
				Needs for instance to handle additional input series that are indexed over index sets that don't appear in the sub-model.
			
			To fix some issues, we should probably scan a decl body for declarations, *then* process them. E.g. to make sure inline decls are also processed out of order.
			This could also allow us to have static if expressions. Would just have to resolve outer consts and parameters first, but that should be ok.
				(see more in doodle)
				
		
		The system of automatic solvers unnecessarily puts soil TDP on a solver in SimplyP. Should be a way to specify it not to. Or maybe even for it to detect that it is not necessary.
			Actually, this should be detected. It should be omitted because the value is an override, and none of the dependencies are on solvers. Instead of having auto-solver with an override, let the solver propagate as for properties.
			
		More cleanup of State_Var system
			the way we handle regular_aggregates of fluxes is not necessarily that nice.
			organize unit_conversion_tree differently.
				and clean up how it is applied.
		Maybe have a separate lookup structure for fluxes and have the common flux things stored there.
			(in many cases we just loop over all fluxes and try to find common things for them)
			loc1, loc2, unit_conv, connection, etc.
				
		Let '/' always be a real division, and maybe have a separate operator // (or similar) to force integer division.
		
		Finish sub-indexed index sets
			May need to zero out fluxes across (as in connections) the super index set if they also index over the sub index set. (mostly relevant for all_to_all, grid1d (and graph)).
			Sub-indexed series data.
			
			Make MobiView2 display if a selected series was not computed.
				Not needed anymore? they should not be selectable.
			
		Go over and improve diagnostics in error messages (all over the place).
		
		external_computation : 
			Just do whatever is needed when it is needed.
			
		Load modules from modules (?)
			Probably difficult wrt. multiple loads of the same base module. Unless we also scope the module names recursively.
			Doesn't seem to be that necessary.
		
	*** Low-pri ****
	
		Iterate in function scope.
			Make the iter_tag be referencable as an iterator.
			Do reassignable local vars with phi nodes instead of alloca.
			
		Maybe implement reverse iteration for grid1d
			if you have a property depending on the [below] of itself.
	
		Make out_flux (?)
			out_flux(connection, substance) first.
			Also out_flux(substance).
			Could also have out_flux(target, substance) (And also for in_flux).
				where target is either a connection or a location.
			Replace things like 'flow' in some places? Maybe doesn't work.
			
			Or do we just wait since out_flux could always be computed with a property.
			
			
	
		Make a Token ole_get_token(VARIANT *var) that can streamline some of the excel reading.
	
		Give proper error when externally linked function is not found.
			Currently it just doesn't compile the module functions, and only gives error when trying to look up the module functions saying *they* are not found.
	
		Make the data_set declarations match the model declarations better
			
			data_set { } declaration.
		
			And maybe reuse the entire registry and scope structure so that we can serialize in the data set, then deserialize in the model to transfer the entity automatically.
		
			Just let the data_set use the same AST, where a [] block parses as "data", which is just a token list.
				However this is problematic for large data such as "series". Could also just put the source_loc there and restart the stream.
				Maybe better: don't allow inline series in the main data file, and always require that they are included! (yes! then we also don't have to support printing them)
			
			Could have a serialization name for entities in the data set and use that to map them over to the model? Then use Entity_Id inside the data_set, but just map these to the model entity_ids.
		
			Just make one Index_Data structure that can be reused between Data_Set and Model_Application
				Handles all get_count, get_instance_count, name lookup etc. etc.
			
			Index sets refereced inside unused modules have still to be declared in the data set.
				Difficult to get rid of. May need to allow the index sets to be declared even though they are not in the model.
		
	
		Is there any way we could simplify 'aggregation_weight' and 'unit_conversion' so that they don't have to be declared like that?
		
		Maybe the decl_type of module template should just be module_template (in the module files).
		
		It can sometimes be very difficult to debug what is going on when one forgets to put a quantity on a solver and this doesn't give an error for dependency reasons.
		
		Capping of discrete fluxes from override variables not necessary?
			I.e. don't have to check if a flux with the source in a variable that is 'override' overtaxes its source.
		
		
		Current override system of inputs on properties is not the best. Should be possible on a per-index basis (but that requires something like input_was_provided in Mobius1)
			Similarly also want to allow inputs to override parameters.
		
		MobiView:
		
			Plot
			
				Make a date range for the 2D plot (when the date is the x axis) that defaults to no more than say 1000 steps.
				
				stacked_share has a slow implementation.
					Should maybe not sum over all the values each time it is extracted, just do it once and store it.
				Normalized axis needs to be more robust.
				Flickering axis labels when scrolling.
				
				All-NaN line is broken (ScatterDraw bug - report to them!)
				
				"Network" plot for connections. Draw the network along with amount (of some quantity(ies)) as bar plot per node. Animate over time.
					Maybe not just for connection, but for any graph of that quantity?
					Allow multiple bars for several quantities or instances of.
					
				How to do unit of sum of reach flow if the reach flow unit is in m3/s and the sum is over days?
				Could have both aggregation none and days, and in the later case it also aggregates m3/s -> m3/day .
					A bit annoying do it from a coding perspective though because you have to work with declared units, not standardized units.
					
				Trend line doesn't make sense for some aggregations.
				Make the residual trend one of the available residual statistics (in terms of optim. it should be minimized in absolute value).
			
			Sensitivity & optimization - new features
				Fix serialization again.
				Make the code better so that it is not so easy to have bugs when adding/removing/moving parameters.
				Combine simple sensitivity into the advanced sensitivity setup.
					Compute statistics of the target stat like variance etc.
					Allow for 2 parameters, with a surf plot eventually.
				GLUE-like sampling?
				Serialize sensitivity setups using a Mobius format instead of json so that we can load the same setups in mobipy eventually.
				More customizable target functions.
				Targets computed from aggregate series (stats of aggregate series).
				
				Optimizer callback doesn't update additional plot view.
				
				Selection of matrix column parameters is incorrect.
				
				
			Something where you can plot individual functions / state vars as functions of their inputs.
			
			Finish all missing functionality from MobiView1
				Index set editing (Will now include connection editing).
				
				Maybe need a reshape() function on the Data_Set or something like that.
								
			tweaks to the state var tree organization
				The icons in "by quantity" view are currently not that intuitive.
				Allow order by flux? By module?
			
			More aggregation intervals
				minute, hour, day. (esp. day).
			
		
		More mobipy functionality.
			And fix it again... 
		
		Some kind of system for specifying assertion checks on user provided data, such as
			lu_prop should sum to 1 over landscape units.
			Some parameter bounds are absolute.
	
	
		Make it possible to free file memory before a model is deleted.
			Requires ASTs to copy some string data, which is a bit annoying since right now they store Tokens directly.
		
		Set units of regular aggregation state variables so that they display correctly if viewed.
			note that it is a bit tricky for fluxes.
			
		aggregate() of series and parameters, or even of arbitrary expressions.
			Would need a separate instruction type for it.
			For parameters, ideally it should just be computed once using the constant system described above.
			For arbitrary expressions, it could be tricky to figure out what compartment it actually aggregates from.
		
		Make discrete fluxes work like other fluxes for aggregation stuff so that everything works the same way for them (including some connection stuff).
			Reimplement discrete fluxes for connections in some situations.
				Should always be possible for grid1d.
				Also for graph if it is no_cycles and we force those to be ordered correctly.
			This may not go well with the above suggested change though.
		
		Would like to get the assembly code for the model, but it is apparently notrivial. Can get the obj by using a dummy object cache that dumps the memory
			https://github.com/llvm/llvm-project/blob/main/llvm/examples/OrcV2Examples/LLJITWithObjectCache/LLJITWithObjectCache.cpp
			One could then manually disassemble it.
		
		Other solver algorithms.
		
		Declaring units with a handle and reusing that handle does not quite work, at least not for parameters.
		
		last(something) doesn't automatically cause it to have an initial value computation (if one was not set).
		
		Error if you access time.fractional_step outside a solver? Or it just defaults to 0?

		Re-consolidate input loading with the serialization system (In terms of how it looks up ids of names).
			Tricky...
			
	Probably not ?:
	
		If a dissolved substance can flow somewhere, you don't have to declare that it is there (?)
			Maybe only if you specify it to disperse.
			could be tricky wrt units.
			could be tricky since right now we assume all quantities are declared.
			how to determine initial value?
			sometimes you don't want it there (though that could be accomplished with no_carry)
	
		Selecting profile or profile2d should select all the indexes if only one index set is active and only one index is selected.
			Maybe not desirable
	
		The "loose depends" system is kind of iffy.
			I think there are no guarantee that something is not placed in a for loop too late initially. Esp. bc of how create_batches works.
				This in particular may have been fixed now.
	
	NOTES
		
	Hope for reply on one of these 
		https://discourse.llvm.org/t/how-to-generate-ir-so-that-the-loop-vectorizer-can-vectorize-it/69096/2
		https://stackoverflow.com/questions/75674759/llvm-loop-vectorizer-does-not-vectorize-my-ir?noredirect=1#comment133504571_75674759
		


	*** High pri ***


		Finish the new formulation of special_computation
			Maybe we should specify the index sets directly rather than doing it in the roundabout way we do now (specifying the compartment) (?)
			
			Make in_flux and out_flux be allowed as inputs to it.
			
			See the note in
				nivafjord/horizontal_fluxes.txt "Place river horizontal fluxes"
				
				Problem with how one should identify what the source compartment of the lookup layer.water.rho[horz.below] is
				Right now we default it to the compartment of the result(), but that is very error prone.
			
			Rename to 'external_computation' ?
			

		Dependency system for connection aggregations is very error prone and complicated. Esp. wrt. 'top' and 'bottom'.
			(in terms of how it is computed, not in terms of user-facing functionality)
			Ideally the entire system should be re-thought or restructured.

		Specific models
			Finish NIVAFjord!!
				horizontal fluxes -> where do they push water out to?
				Also the restriction of vertical fluxes to the layers that 'participate' in the edge of that connection.
				
			Finish the simple hydraulics model.
			
			EasyLake-CNP

		
		Finish connection system
		
			in_flux(connection, something) will some times depend on the indexes being ordered in the same way as in the connection graph.
				Happens if a flux along the connection (in)directly depends on the in_flux(connection, something).
				This is not solvable without remapping the indexes (or asking the user to reorder them).
				Could detect if this happens and give an error, but that alone is a bit of work.
					But that is needed if it happens in a graph with cycles.
		
			Component index sets should probably be declared in the connection declaration in the model. It is too integral to how to model works to leave it to data set.
			
			Have to figure out what something like
					flux(blabla, something[vert.below], ...)				
			means. Right now the location 'something' is not used.
				Need this for NIVAFjord
			Maybe just make the syntax
					flux(blabla, any[vert.below]
			and disallow having specific location there. And this is what we do for all 'below' connection targets.
				Could later extend it to have different code depending on the target (for graph and directed_tree).
			
			Make 'pair' connection (?).
				Allows avoiding things like having an outlet index set for river->fjord   or e.g.  sewage->river.
					Could just use a directed tree for this though..
			
			graph and tree
				One should need to explicitly allow isolated nodes using something like    a | (....)
			
			graph connections
				
				For [below] accesses in flux, we probably need to pre-process them to check that the units are the same in all instances etc. and that "indexing below" is correct.
					Alternatively do unit conversions, but how?
					May have to be done inside resolve_function_tree, so we need to access the connection data there.

			all_to_all:
				
				Maybe signal that something can be a matrix parameter by having a double dependency on that compartment in the par group?

			grid1d:	
				allow 'top' to be the source of a flux (?) (and 'bottom' be a target).
				
					
			Specific target:
				Properly process the @specific function tree, incl. flags
				Check valid dependencies for the tree.
					Have to think about what types of variables it is allowed to reference.
				Tridiagonal distribution.
				Clamp the index within allowed bounds or zero out the flux if the index is out of bounds (?).
					This is actually the only feature currently where a user error could lead to unsafe memory accesses. Unless we add the constraints.
			
			Dissolved fluxes -
				make dissolvedes of negatives work for other types (graph (maybe) regular fluxes (maybe), but probably not directed tree).
			
	
	*** Intermediate-pri ***
	
		Ignore certain log_print if not in "developer mode" (should be configured in config.txt)
	
		In NIVAFjord we get too many index sets for MobiView2 to handle.
			Either organize edge index sets differently.
			Or rethink the entire system
				Hide index sets that are not active, for instance (and place the other selectors nicely).
			Or make a few more, but will not solve problem long term (?)
			Or select edge by selecting what it is pointing at (?) - doesn't work if it is pointing at something indexed the same way (in that case would need something like the all_to_all).
			Do the same as all_to_all. - Just plot all of them. (Doesn't solve for parameter selection).
			Make a different way to organize sub-indexed index sets (could also solve other problems).
	
	
		Some system for specifying state variables that should not be stored (properties only).
			Quite complicated. In practice, need a separate storage for them that is only 1 deep. Also must disallow last() on them etc.
			First iteration could be to just not display them, but still have them stored in the same place as everything else
		Also a system for specifying different display variants (along with the code in MobiView2 to make use of that, which is the hard part).
		
		Consider just adding connection fluxes to derivatives as they are computed instead of having so many aggregates (except when these are actually needed, which would be much less often).
			This would be a major change, but could create some speedup.
			Alternatively, have them be non-stored as a default. (Requires less drastic changes, but has almost the same benefits of less memory usage).
		
		Make an (optional) validator that validates the order of instructions in the final structure according to (various types of) dependencies!
			Useful for catching errors, which we some times have but are slow to detect.
		
		override {}  declaration.
			E.g. to change the connection regex of a connection in an extending model.
			How to do it for no_carry?
				The way we now do no_carry is in general maybe not that good after all.
				May eventually need to specify no_carry outside the module the flux was already declared in, but let's wait and see.

		Clean up the Vansj√∏ input data (merge sheets). Maybe re-download some of it.
	
		Clean up the prune_tree system.
			Could get rid of using Function_Scope in prune_helper?
				Tried it, but it has a bug.
			Easy to have leaks when moving and deleting nodes the way it is done now.

		Normalized file paths can be different depending on how they were loaded using relative paths. This causes it some times to try to load the same library twice, which causes a name clash.
			Need a fully standardized normalized path (?)

		It could probably be better if you *only* declare the time unit for the flux
			Alternatively need some way to construct units, like
				combine_unit(soil.water.oc.tox, [day-1])
			This has to do with module reusability, could apply the module to quantities with different units.
				
		error_print_location
			We could pass a scope to it, and only let it fall back on get_symbol when necessary.
				(it can be necessary if the location was passed as a loc() to the scope where it is being used).
			Make it print the bracket if needed.

		More on module loading and the declaration format:
				
			Dynamic module choice (based on data set)
				
			Whether or not something is formatted as a var_location could be checked already in the match_declaration stage (e.g. Not just pass it as Token_Type::identifier).
			
			For properties, maybe always just put the unit on the property (but not on quantities obviously).
			
			Make it easier to load a sub-model of a larger model with a data set that was declared for the larger model.
				Needs for instance to handle additional input series that are indexed over index sets that don't appear in the sub-model.
		
			Check for conflicting declarations of variables (unit, name).
			
			To fix some issues, we should probably scan a decl body for declarations, *then* process them. E.g. to make sure inline decls are also processed out of order.
			This could also allow us to have static if expressions. Would just have to resolve outer consts and parameters first, but that should be ok.
				(see more in doodle)
				
		
		The system of automatic solvers unnecessarily puts soil TDP on a solver in SimplyP. Should be a way to specify it not to. Or maybe even for it to detect that it is not necessary.
			Actually, this should be detected. It should be omitted because the value is an override, and none of the dependencies are on solvers. Instead of having auto-solver with an override, let the solver propagate as for properties.
			
		More cleanup of State_Var system
			the way we handle regular_aggregates of fluxes is not necessarily that nice.
			organize unit_conversion_tree differently.
				and clean up how it is applied.
		Maybe have a separate lookup structure for fluxes and have the common flux things stored there.
			(in many cases we just loop over all fluxes and try to find common things for them)
			loc1, loc2, unit_conv, connection, etc.
				
		Let '/' always be a real division, and maybe have a separate operator // (or similar) to force integer division.
		
		Finish sub-indexed index sets
			May need to zero out fluxes across (as in connections) the super index set if they also index over the sub index set. (mostly relevant for all_to_all, grid1d (and graph)).
			Sub-indexed series data.
			
			Make MobiView2 display if a selected series was not computed.
			
		Go over and improve diagnostics in error messages (all over the place).
		
		The 'extend' system is just not that good.
			- There are problems when you want to override something in the earlier model,
			- There is a problem if two extended models declare the same symbol.
			
			It is mainly nice for loading other modules, declaring some parameters, and aggregation_weight / unit_conversion, index set, distribution, solvers
			The rest (declaring compartment, quantity, property) could easily be redone in the extending model.
			
			Maybe we could have an
				if_main {
				}
			block. Things there are only processed if that model is loaded as the main one.
				This rids us of the necessity to override model extensions.
					Downside is that the extended model needs to know what things other models want to override....... Hmmm...
					Also, if e.g. 'downstream' is in an if_main (since easylake or nivafjord may want to override it), then e.g. SimplyP also has to redeclare it...
			
			Could have an named_block("Name") { } block, and turn off blocks when extending
				extend("simplyq_model.txt", "Name") turns off "Name".
				
				What about nested extensions in this system, and two models extend the same thing but disagree.
					...nightmare...
		Alternative: We just redeclare the entire model structure when that is necessary (which is what we do now).
		
		
	*** Low-pri ****
	
		Iterate in function scope.
			Make the iter_tag be referencable as an iterator.
			Do reassignable local vars with phi nodes later. For now, just use alloca.
			
	
		Maybe implement reverse iteration for grid1d
			if you have a property depending on the [below] of itself.
	
		Make out_flux (?)
			out_flux(connection, substance) first.
			Also out_flux(substance).
			Could also have out_flux(target, substance) (And also for in_flux).
				where target is either a connection or a location.
			Replace things like 'flow' in some places? Maybe doesn't work.
			
			Or do we just wait since out_flux could always be computed with a property.
			
			
	
		Make a Token ole_get_token(VARIANT *var) that can streamline some of the excel reading.
	
		Give proper error when externally linked function is not found.
			Currently it just doesn't compile the module functions, and only gives error when trying to look up the module functions saying *they* are not found.
	
		Make the data_set declarations match the model declarations better
			Just let the data_set use the same AST, where a [] block parses as "data", which is just a token list.
			Should be able to make registries match up better to simplify some things when loading into the Model_Application.
			
			Could have a serialization name for entities in the data set and use that to map them over to the model? Then use Entity_Id inside the data_set, but just map these to the model entity_ids.
		
			
			Index sets refereced inside unused modules have still to be declared in the data set.
				Difficult to get rid of. May need to allow the index sets to be declared even though they are not in the model.
		
		
		More correctness checks and convenience etc. for uses of Indexes.
			count()
			Maybe just have an iterator on Indexes that includes mat_col if necessary.
				Use that in check_for_nans and maybe other places. get_index_names_with_edge_naming, etc.
		
	
		Is there any way we could simplify 'aggregation_weight' and 'unit_conversion' so that they don't have to be declared like that?
		
		Maybe the decl_type of module template should just be module_template (in the module files).
		
		It can sometimes be very difficult to debug what is going on when one forgets to put a quantity on a solver and this inadvertently doesn't give an error.
		
		Capping of discrete fluxes from override variables not necessary?
			I.e. don't have to check if a flux with the source in a variable that is 'override' overtaxes its source.
		
		
		Separate var storage that is not temporal
			Current override system of inputs on properties is not the best. Should be possible on a per-index basis (but that requires something like input_was_provided in Mobius1)
			Similarly also want to allow inputs to override parameters.
		
			Check for constant computability of properties (or constant series or constant state vars) and have them stored in a separate structure that is computed at model startup.
			Must also handle if there is a constant .override
				Can use the same storage as for variables that are not stored temporally.
		
		Just make the global module in the data set be a module scope in the data set. Simplifies things a bit. Maybe a module {} without a name (?)
		
		
		MobiView:
		
			Parameter search & select crashes on 'Start date'
		
			Plot
				stacked_share has a slow implementation.
					Should maybe not sum over all the values each time it is extracted, just do it once and store it.
				Grid line offsets are sometimes strange when you switch to Profile2D then back to regular.
				Normalized axis needs to be more robust.
				Flickering axis labels when scrolling.
				
				All-NaN line is broken (ScatterDraw bug - report to them!)
				
				"Network" plot for connections. Draw the network along with amount (of some quantity(ies)) as bar plot per node. Animate over time.
					Maybe not just for connection, but for any graph of that quantity?
			
			Sensitivity & optimization - new features
				Combine simple sensitivity into the advanced sensitivity setup.
					Compute statistics of the target stat like variance etc.
					Allow for 2 parameters, with a surf plot eventually.
				GLUE-like sampling?
				Serialize sensitivity setups using a Mobius format instead of json so that we can load the same setups in mobipy eventually.
				More customizable target functions.
				Targets computed from aggregate series (stats of aggregate series).
				
				Optimizer callback doesn't update additional plot view.
				
				Matrix parameters don't serialize/deserialize correctly.
					Probably same with optimization target.
				
				
				
			Something where you can plot individual functions / state vars as functions of their inputs.
			
			Finish all missing functionality from MobiView1
				Index set editing (Will now include connection editing).
								
			tweaks to the state var tree organization
				The icons in "by quantity" view are currently not that intuitive.
				Allow order by flux? By module?
				
			How to do unit of sum of reach flow if the reach flow unit is in m3/s and the sum is over days?
				Could have both aggregation none and days, and in the later case it also aggregates m3/s -> m3/day .
					A bit annoying do it from a coding perspective though because you have to work with declared units, not standardized units.
			
			More aggregation intervals
				minute, hour, day. (esp. day).
				
			Trend line doesn't make sense for some aggregations.
			Make the residual trend one of the available residual statistics (in terms of optim. it should be minimized in absolute value).
		
		More mobipy functionality.
		
		Some kind of system for specifying assertion checks on user provided data, such as
			lu_prop should sum to 1 over landscape units.
		
		boundary conditions for other types of connections (not grid1d)
			For instance, what happens to the flux in a directed tree if it doesn't have a valid target, is it still computed (yes in some cases, maybe no in others)
			similar for graph when that exists.
		In grid1d, could have wrap-around boundary (?), or could have special values for the boundary (maybe even dynamic)
	
	
		Make it possible to free file memory before a model is deleted.
			Requires ASTs to copy some string data, which is a bit annoying since right now they store Tokens directly.
		
		
		Set units of regular aggregation state variables so that they display correctly if viewed.
			note that it is a bit tricky for fluxes.
			
			
		aggregate() of series and parameters, or even of arbitrary expressions.
			Would need a separate instruction type for it.
			For parameters, ideally it should just be computed once using the constant system described above.
			For arbitrary expressions, it could be tricky to figure out what compartment it actually aggregates from.
		
		
		Aggregation variables are not always necessary if we could just add things to derivatives directly, but this is not the case always.
			Would require a big systemic change to model_compilation and model_codegen to implement this.
		
		Make discrete fluxes work like other fluxes for aggregation stuff so that everything works the same way for them (including some connection stuff).
			Reimplement discrete fluxes for connections in some situations.
			This may not go well with the above suggested change though.
		
		
		Would like to get the assembly code for the model, but it is apparently notrivial. Can get the obj by using a dummy object cache that dumps the memory
			https://github.com/llvm/llvm-project/blob/main/llvm/examples/OrcV2Examples/LLJITWithObjectCache/LLJITWithObjectCache.cpp
			One could then manually disassemble it.
		
		Other solver algorithms.
		
		Different Var_Restrictions resulting in the same condition on the index, and causing multiple checks of the same condition (in model_codegen).
		
		Declaring units with a handle and reusing that handle does not quite work, at least not for parameters.
		
		last(something) doesn't automatically cause it to have an initial value computation (if one was not set).
		
		Error if you access time.fractional_step outside a solver? Or it just defaults to 0?

		Re-consolidate input loading with the serialization system (In terms of how it looks up ids of names).
			Tricky...
			
		The "loose depends" system is kind of iffy.
			I think there are no guarantee that something is not placed in a for loop too late initially. Esp. bc of how create_batches works.
				This in particular may have been fixed now.

	Probably not ?:
	
		If a dissolved substance can flow somewhere, you don't have to declare that it is there (?)
			Maybe only if you specify it to disperse.
			could be tricky wrt units.
			could be tricky since right now we assume all quantities are declared.
			how to determine initial value?
			sometimes you don't want it there (though that could be accomplished with no_carry)
	
		Selecting profile or profile2d should select all the indexes if only one index set is active and only one index is selected.
			Maybe not desirable
	
	
	
	NOTES
		
	Hope for reply on one of these 
		https://discourse.llvm.org/t/how-to-generate-ir-so-that-the-loop-vectorizer-can-vectorize-it/69096/2
		https://stackoverflow.com/questions/75674759/llvm-loop-vectorizer-does-not-vectorize-my-ir?noredirect=1#comment133504571_75674759
		


module("HBVSnow lite", 1,0,0) {
	"A snow module"

	air        : compartment("Atmosphere")
	snow_box   : compartment("Snow box")
	
	snow_par :
	snow_box.par_group("Snow") {
		#test      : par_real("Test", a, 1)   # should give error. a is not declared anywhere
		ddf_melt  : par_real("Degree-day factor for snowmelt", unit(m m, deg_c -1, day -1), 2.74, "Some description")
		t_snow    : par_real("Temperature at which precip falls as snow", unit(deg_c), 0)
		t_melt    : par_real("Temperature at which snow melts", unit(deg_c), 0)
		refreeze  : par_real("Refreeze efficiency", unit(), 0.5)
		snow_liq  : par_real("Liquid water fraction", unit(), 0.5)
		init_snow : par_real("Initial snow depth (water equivalents)", unit(), 0)
	}
	
	snow  : substance("Snow (water equivalents)")
	water : substance("Water")
	
	# note: we don't say air.has(temp) ... etc. This means that it is "hanging" and so assumed to be an input series, unless another module declares a function for it.
	
	temp   : property("Temperature", unit(deg_c))
	precip : property("Precipitation", unit(m m, day -1))
	
	snow_box.has(snow,  unit(m m)) .initial { init_snow }
	snow_box.has(water, unit(m m)) .initial { 0 }             # Not necessary to declare initial here, default is 0.
	
	
	
	# Source nowhere means that we are not interested in tracking the state of the source, this is then a pure source to the system
	flux(nowhere, snow_box.snow, "Precipitation falling as snow") {
		air.precip    if air.temp <= t_snow,
		0             otherwise
	}
	
	# target out means that this module does not know what the target is. The target has to be linked in the model composition later.
	p_rain :
	flux(nowhere, out, "Precipitation falling as rain") {
		air.precip    if air.temp > t_snow,
		0             otherwise
	}
	
	flux(snow_box.snow, snow_box.water, "Melt") {
		min(max(0, ddf_melt*(air.temp - t_melt)), last(snow_box.snow))
	}
	
	# It would be good if we don't have to declare min(..., last(snow_box.water)) here and instead have it automatic, but it would make order of evaluation of refreeze and melt_runoff ambiguous. Can we figure out a way to make this more clean?
	
	flux(snow_box.water, snow_box.snow, "Refreeze") {
		min(max(0, refreeze*ddf_melt*(t_melt - air.temp)), last(snow_box.water))
	}
	
	#flux(air.water, snow_box.water) { 0 }   # should give error. We have not declared air.has(water)
	
	melt_runoff :
	flux(snow_box.water, out, "Melt runoff") {
		max(0, snow_box.water - snow_box.snow*snow_liq)
	}
}

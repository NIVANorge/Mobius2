

module("SimplyQ land", 0, 5, 0) {
"""
This is an adaption of a hydrology module originally implemented in Python as a part of the model SimplyP, which was published as

[Jackson-Blake LA, Sample JE, Wade AJ, Helliwell RC, Skeffington RA. 2017. Are our dynamic water quality models too complex? A comparison of a new parsimonious phosphorus model, SimplyP, and INCA-P. Water Resources Research, 53, 5382â€“5399. doi:10.1002/2016WR020132](https://doi.org/10.1002/2016WR020132)
"""
	load("../../stdlib/basic_math.txt", library("Response"))    #TODO: we need a better way to address the stdlib so that we don't have to know the path.

	soil     : compartment("Soil")
	gw       : compartment("Groundwater")
	
	water : quantity("Water")
	
	soil.par_group("Hydrology general") {
		bfi    : par_real("Baseflow index", unit(), 0.6)
		qqinfl : par_real("Quick flow inflection point", unit(), 160)
	}
	
	soil.par_group("Hydrology land") {
		fc     : par_real("Field capacity", unit(m m), 120)
		tc_s   : par_real("Soil water time constant", unit(day -1), 2)
	}
		
	gw.  par_group("Groundwater") {
		tc_g    : par_real("Groundwater time constant", unit(day -1), 30)
	}
	
	soil.has(water, unit(m m), "Soil water volume") .initial { fc }
	gw  .has(water, unit(m m), "Groundwater volume") .initial { 0 } # TODO!

	pet  : property("Potential evapotranspiration")
	
	quick_flow :
	flux(soil.water, out, "Quick flow") {
		drylim := 0.9		# Could be a parameter. Stops quick flow below drylim*fc
		flow   := in_flux(water)
		flow * s_response(water, drylim*fc, fc, 0, 1) * (2 / (1 + exp(-2*flow/qqinfl)) - 1)
	}
	
	flux(soil.water, nowhere, "Evapotranspiration") {   pet*(1 - 0.01^(water/fc))   }  # = pet*(1 - exp(ln(0.01)*water/fc)) #NOTE: these two are equivalent formulations due to optimizations.
	
	soil.has(flow : property("Flow"), unit(m m, day -1), "Soil water flow") {
		rate := (water - fc)/tc_s
		s_response(water, fc, 1.01*fc, 0, rate) # smoothly turn the rate on between water volumes of fc and 1.01*fc
	}
	
	soil_runoff :
	flux(soil.water, out, "Soil runoff")            {   soil.flow * (1 - bfi)   }
	
	flux(soil.water, gw.water, "Recharge")          {   soil.flow * bfi   }
	
	gw_runoff :
	flux(gw.water, out, "Groundwater runoff")       {   water / tc_g   }
}


module("SimplyQ river", 0, 0, 1) {
"""
The river part of the SimplyQ module.
"""

	river : compartment("River")
	
	water : quantity("Water")
	
	river.par_group("Reach parameters") {
		slope          : par_real("Reach slope", unit(), 0.014)
		len            : par_real("Reach length", unit(m), 10000)
		c_mann         : par_real("Manning's roughness coefficient", unit(), 0.04)
		init_flow      : par_real("Initial reach flow", unit(m 3, s-1), 1)
	}
	
	flow : property("Flow")
	
	river.has(water, unit(m 3), "Reach water volume") .initial {
		depth := 0.349 * flow^0.34
		width := 2.71 * flow^0.557
		width * depth * len
	}

	#eff_len := len * 0.5   #TODO: should be a computed parameter.
	river.has(flow, unit(m 3, s -1), "Reach flow")    { 0.28 * (water * sqrt(slope) / (len * c_mann))^1.5   } .initial { init_flow 	}
	
	#TODO: link up river segments!
	reach_out :
	flux(river.water, out, "Reach flow flux")     {	 flow * 86400  }                  #NOTE: explicit unit conversion should be removed once we get automatic unit checks 

	#river.has(property("In flow"), unit(m 3, day -1)) {  in_flux(water)  } #NOTE: for debugging
}
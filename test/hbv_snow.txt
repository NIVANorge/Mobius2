

module("HBVSnow lite", 1,0,0) {
"""
A nice snow module.
With some extra spice.
"""

	air        : compartment("Atmosphere")
	snow_box   : compartment("Snow box")
	
	snow_par :
	snow_box.par_group("Snow") {
		#test      : par_real("Test", a, 1)   # should give error. a is not declared anywhere
		ddf_melt  : par_real("Degree-day factor for snowmelt", unit(m m, deg_c -1, day -1), 2.74, "Some description")
		t_snow    : par_real("Temperature at which precip falls as snow", unit(deg_c), 0, -4, 4, "More description")
		t_melt    : par_real("Temperature at which snow melts", unit(deg_c), 0)
		refr_eff  : par_real("Refreeze efficiency", unit(), 0.5)
		snow_liq  : par_real("Liquid water fraction", unit(), 0.5)
		init_snow : par_real("Initial snow depth (water equivalents)", unit(), 10)
	}
	
	snow  : quantity("Snow (water equivalents)")
	water : quantity("Water")
	
	# note: We don't give a function body to compute these, and so if they are not re-declared in another module, they are assumed to be input series.
	air.has(temp : property("Temperature"), unit(deg_c), "Air temperature")
	air.has(precip : property("Precipitation"), unit(m m, day -1))
	
	snow_box.has(snow,  unit(m m), "Snow depth") .initial { init_snow }
	snow_box.has(water, unit(m m), "Snow water") #.initial { 0 }             # Not necessary to declare initial here, default is 0.
	
	my_min : function(a, b) {
		a  if a <= b,
		b  otherwise
	}
	
	snow_box.has(temp, unit(deg_c), "Soil temperature") {
		ddf_melt
	}
	
	# Source nowhere means that we are not interested in tracking the state of the source, this is then a pure source to the system
	p_snow :
	flux(nowhere, snow_box.snow, "Precipitation falling as snow") {
		air.precip    if air.temp <= t_snow,
		0             otherwise
	}
	
	# target out means that this module does not know what the target is. The target has to be linked in the model composition later.
	p_rain :
	flux(nowhere, out, "Precipitation falling as rain") {
		air.precip    if air.temp > t_snow,
		0             otherwise
	}
	
	# NOTE: default is that a flux should never make a quantity go negative. Maybe allow specifying that a quantity *could* go negative (e.g. if you model potential energy or something)
	
	melt :
	flux(snow_box.snow, snow_box.water, "Melt") {
		max(0, ddf_melt*(air.temp - t_melt))
	}
	
	# TODO: order of evaluation of refreeze and melt_runoff are ambiguous. Can we figure out a way to specify it?
	
	refreeze :
	flux(snow_box.water, snow_box.snow, "Refreeze") {
		max(0, refr_eff*ddf_melt*(t_melt - air.temp))
	}
	
	#flux(air.water, snow_box.water, "Smurk") { 0 }   # should give error. We have not declared air.has(water)
	
	melt_runoff :
	flux(snow_box.water, out, "Melt runoff") {
		max(0, snow_box.water - snow_box.snow*snow_liq)
	}
}
